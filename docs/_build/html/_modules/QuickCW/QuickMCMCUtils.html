<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>QuickCW.QuickMCMCUtils &mdash; QuickCW  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            QuickCW
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">QuickCW</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">QuickCW.QuickMCMCUtils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for QuickCW.QuickMCMCUtils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;C 2021 Bence Becsy</span>
<span class="sd">MCMC for CW fast likelihood (w/ Neil Cornish and Matthew Digman)</span>
<span class="sd">Helpers for MCMC; extrinsic blocks and parallel tempering&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">perf_counter</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1">#np.seterr(all=&#39;raise&#39;)</span>
<span class="c1">#make sure to use the right threading layer</span>

<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span><span class="n">prange</span>
<span class="kn">from</span> <span class="nn">numba.typed</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">uniform</span>

<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">import</span> <span class="nn">QuickCW.CWFastPrior</span> <span class="k">as</span> <span class="nn">CWFastPrior</span>
<span class="kn">from</span> <span class="nn">QuickCW.QuickCorrectionUtils</span> <span class="kn">import</span> <span class="n">check_merged</span><span class="p">,</span><span class="n">correct_extrinsic</span><span class="p">,</span><span class="n">correct_intrinsic</span>
<span class="kn">import</span> <span class="nn">QuickCW.const_mcmc</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">QuickCW.CWFastLikelihoodNumba</span> <span class="k">as</span> <span class="nn">CWFastLikelihoodNumba</span>
<span class="kn">from</span> <span class="nn">QuickCW.QuickFisherHelpers</span> <span class="kn">import</span> <span class="n">get_fishers</span>
<span class="kn">from</span> <span class="nn">QuickCW.QuickMTHelpers</span> <span class="kn">import</span> <span class="n">do_intrinsic_update_mt</span><span class="p">,</span><span class="n">add_rn_eig_jump</span>
<span class="kn">from</span> <span class="nn">QuickCW.OutputUtils</span> <span class="kn">import</span> <span class="n">print_acceptance_progress</span><span class="p">,</span><span class="n">output_hdf5_loop</span><span class="p">,</span><span class="n">output_hdf5_end</span>

<span class="c1">################################################################################</span>
<span class="c1">#</span>
<span class="c1">#UPDATE INTRINSIC PARAMETERS AND RECALCULATE FILTERS</span>
<span class="c1">#</span>
<span class="c1">################################################################################</span>
<span class="c1">#version using multiple try mcmc (based on Table 6 of https://vixra.org/pdf/1712.0244v3.pdf)</span>

<span class="c1">###############################################################################</span>
<span class="c1">#</span>
<span class="c1">#REGULAR MCMC JUMP ROUTINE (JUMPING ALONG EIGENDIRECTIONS)</span>
<span class="c1">#</span>
<span class="c1">################################################################################</span>
<div class="viewcode-block" id="do_extrinsic_block"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.do_extrinsic_block">[docs]</a><span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do_extrinsic_block</span><span class="p">(</span><span class="n">n_chain</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">itrb</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">x0s</span><span class="p">,</span> <span class="n">FLIs</span><span class="p">,</span> <span class="n">FPI</span><span class="p">,</span> <span class="n">n_par_tot</span><span class="p">,</span> <span class="n">log_likelihood</span><span class="p">,</span> <span class="n">n_int_block</span><span class="p">,</span> <span class="n">fisher_diag</span><span class="p">,</span> <span class="n">a_yes</span><span class="p">,</span> <span class="n">a_no</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;do blocks of just the extrinsic parameters, which should be very fast&quot;&quot;&quot;</span>
    <span class="n">n_par_ext</span> <span class="o">=</span> <span class="n">x0s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">idx_cw_ext</span><span class="o">.</span><span class="n">size</span>

    <span class="c1">#treat all phases where fisher is saturated as 1 parameter for counting purposes in jump scaling</span>
    <span class="c1">#saturate_count = np.zeros(n_chain,dtype=np.int64)</span>
    <span class="c1">#for j in range(0,n_chain):</span>
    <span class="c1">#    if Ts[j]&gt;cm.proj_phase_saturate_temp:</span>
    <span class="c1">#        saturate_count[j] = x0s[j].Npsr-1</span>



    <span class="c1">#for j in range(0,n_chain):</span>
    <span class="c1">#    for ii,idx in enumerate(x0s[j].idx_phases):</span>
    <span class="c1">#        if Ts[j]&gt;cm.proj_phase_saturate_temp or np.sqrt(Ts[j])*fisher_diag[j][idx]&gt;=1.9:#cm.sigma_cw0_p_phase_default:</span>
    <span class="c1">#            saturate_count[j] += 1</span>
    <span class="c1">#    #allow one saturated parameter without reducing jump size</span>
    <span class="c1">#    if saturate_count[j] &gt; 1:</span>
    <span class="c1">#        saturate_count[j] -= 1</span>

    <span class="n">jump_scale_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_chain</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">):</span>
        <span class="n">jump_scale_use</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.38</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_par_ext</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_int_block</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_chain</span><span class="p">):</span>
            <span class="n">samples_current</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="n">k</span><span class="p">,:]</span>

            <span class="k">if</span> <span class="n">k</span><span class="o">%</span><span class="mi">4</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span><span class="o">==</span><span class="n">n_chain</span><span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">Ts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">cm</span><span class="o">.</span><span class="n">proj_prior_all_temp</span><span class="p">:</span>  <span class="c1"># every 10th k (so every 5th jump) do a prior draw</span>
                <span class="n">new_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">samples_current</span><span class="p">)</span>
                <span class="n">jump_idx</span> <span class="o">=</span> <span class="n">x0s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">idx_cw_ext</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">jump_idx</span><span class="p">):</span>
                    <span class="n">new_point</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="n">FPI</span><span class="o">.</span><span class="n">cw_ext_lows</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">FPI</span><span class="o">.</span><span class="n">cw_ext_highs</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">jump</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_par_tot</span><span class="p">)</span>
                <span class="n">jump_idx</span> <span class="o">=</span> <span class="n">x0s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">idx_cw_ext</span>
                <span class="n">jump</span><span class="p">[</span><span class="n">jump_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">jump_scale_use</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">fisher_diag</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">jump_idx</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="n">n_par_ext</span><span class="p">)</span>
                <span class="n">new_point</span> <span class="o">=</span> <span class="n">samples_current</span> <span class="o">+</span> <span class="n">jump</span>

            <span class="n">new_point</span> <span class="o">=</span> <span class="n">correct_extrinsic</span><span class="p">(</span><span class="n">new_point</span><span class="p">,</span><span class="n">x0s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="n">x0s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span>

            <span class="n">log_L</span> <span class="o">=</span> <span class="n">FLIs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">log_acc_ratio</span> <span class="o">=</span> <span class="n">log_L</span><span class="o">/</span><span class="n">Ts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">log_acc_ratio</span> <span class="o">+=</span> <span class="n">CWFastPrior</span><span class="o">.</span><span class="n">get_lnprior_helper</span><span class="p">(</span><span class="n">new_point</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">uniform_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">uniform_lows</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">uniform_highs</span><span class="p">,</span>\
                                                                       <span class="n">FPI</span><span class="o">.</span><span class="n">lin_exp_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">lin_exp_lows</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">lin_exp_highs</span><span class="p">,</span>\
                                                                       <span class="n">FPI</span><span class="o">.</span><span class="n">normal_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">normal_mus</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">normal_sigs</span><span class="p">,</span>\
                                                                       <span class="n">FPI</span><span class="o">.</span><span class="n">dm_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">dm_dists</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">dm_errs</span><span class="p">,</span>\
                                                                       <span class="n">FPI</span><span class="o">.</span><span class="n">px_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">px_mus</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">px_errs</span><span class="p">,</span>\
                                                                       <span class="n">FPI</span><span class="o">.</span><span class="n">global_common</span><span class="p">)</span>
            <span class="n">log_acc_ratio</span> <span class="o">+=</span> <span class="o">-</span><span class="n">log_likelihood</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">Ts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">log_acc_ratio</span> <span class="o">+=</span> <span class="o">-</span><span class="n">CWFastPrior</span><span class="o">.</span><span class="n">get_lnprior_helper</span><span class="p">(</span><span class="n">samples_current</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">uniform_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">uniform_lows</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">uniform_highs</span><span class="p">,</span>\
                                                                              <span class="n">FPI</span><span class="o">.</span><span class="n">lin_exp_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">lin_exp_lows</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">lin_exp_highs</span><span class="p">,</span>\
                                                                              <span class="n">FPI</span><span class="o">.</span><span class="n">normal_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">normal_mus</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">normal_sigs</span><span class="p">,</span>\
                                                                              <span class="n">FPI</span><span class="o">.</span><span class="n">dm_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">dm_dists</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">dm_errs</span><span class="p">,</span>\
                                                                              <span class="n">FPI</span><span class="o">.</span><span class="n">px_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">px_mus</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">px_errs</span><span class="p">,</span>\
                                                                              <span class="n">FPI</span><span class="o">.</span><span class="n">global_common</span><span class="p">)</span>

            <span class="n">acc_decide</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">acc_decide</span><span class="o">&lt;=</span><span class="n">log_acc_ratio</span><span class="p">:</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">new_point</span>
                <span class="n">log_likelihood</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_L</span>
                <span class="n">a_yes</span><span class="p">[</span><span class="n">cm</span><span class="o">.</span><span class="n">idx_full</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="n">k</span><span class="p">,:]</span>
                <span class="n">log_likelihood</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="n">k</span><span class="p">]</span>
                <span class="n">a_no</span><span class="p">[</span><span class="n">cm</span><span class="o">.</span><span class="n">idx_full</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">x0s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">samples_current</span><span class="p">)</span>

        <span class="n">do_pt_swap</span><span class="p">(</span><span class="n">n_chain</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">itrb</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">a_yes</span><span class="p">,</span> <span class="n">a_no</span><span class="p">,</span> <span class="n">x0s</span><span class="p">,</span> <span class="n">FLIs</span><span class="p">,</span> <span class="n">log_likelihood</span><span class="p">,</span><span class="n">fisher_diag</span><span class="p">)</span></div>


<span class="c1">################################################################################</span>
<span class="c1">#</span>
<span class="c1">#PARALLEL TEMPERING SWAP JUMP ROUTINE</span>
<span class="c1">#</span>
<span class="c1">################################################################################</span>
<div class="viewcode-block" id="do_pt_swap"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.do_pt_swap">[docs]</a><span class="nd">@njit</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">do_pt_swap</span><span class="p">(</span><span class="n">n_chain</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">itrb</span><span class="p">,</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">a_yes</span><span class="p">,</span> <span class="n">a_no</span><span class="p">,</span> <span class="n">x0s</span><span class="p">,</span> <span class="n">FLIs</span><span class="p">,</span> <span class="n">log_likelihood</span><span class="p">,</span><span class="n">fisher_diag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;do the parallel tempering swap&quot;&quot;&quot;</span>
    <span class="c1">#print(&quot;PT&quot;)</span>

    <span class="c1">#print(&quot;PT&quot;)</span>

    <span class="c1">#set up map to help keep track of swaps</span>
    <span class="n">swap_map</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">))</span>

    <span class="c1">#get log_Ls from all the chains</span>
    <span class="n">log_Ls</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">):</span>
        <span class="n">log_Ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log_likelihood</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="p">])</span>

    <span class="c1">#loop through and propose a swap at each chain (starting from hottest chain and going down in T) and keep track of results in swap_map</span>
    <span class="c1">#for swap_chain in reversed(range(n_chain-1)):</span>
    <span class="k">for</span> <span class="n">swap_chain</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1"># same as reversed(range(n_chain-1)) but supported in numba</span>
        <span class="k">assert</span> <span class="n">swap_map</span><span class="p">[</span><span class="n">swap_chain</span><span class="p">]</span> <span class="o">==</span> <span class="n">swap_chain</span>
        <span class="n">log_acc_ratio</span> <span class="o">=</span> <span class="o">-</span><span class="n">log_Ls</span><span class="p">[</span><span class="n">swap_map</span><span class="p">[</span><span class="n">swap_chain</span><span class="p">]]</span> <span class="o">/</span> <span class="n">Ts</span><span class="p">[</span><span class="n">swap_chain</span><span class="p">]</span>
        <span class="n">log_acc_ratio</span> <span class="o">+=</span> <span class="o">-</span><span class="n">log_Ls</span><span class="p">[</span><span class="n">swap_map</span><span class="p">[</span><span class="n">swap_chain</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">Ts</span><span class="p">[</span><span class="n">swap_chain</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">log_acc_ratio</span> <span class="o">+=</span> <span class="n">log_Ls</span><span class="p">[</span><span class="n">swap_map</span><span class="p">[</span><span class="n">swap_chain</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">Ts</span><span class="p">[</span><span class="n">swap_chain</span><span class="p">]</span>
        <span class="n">log_acc_ratio</span> <span class="o">+=</span> <span class="n">log_Ls</span><span class="p">[</span><span class="n">swap_map</span><span class="p">[</span><span class="n">swap_chain</span><span class="p">]]</span> <span class="o">/</span> <span class="n">Ts</span><span class="p">[</span><span class="n">swap_chain</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">acc_decide</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">acc_decide</span><span class="o">&lt;=</span><span class="n">log_acc_ratio</span><span class="p">:</span><span class="c1"># and do_PT:</span>
            <span class="n">swap_map</span><span class="p">[</span><span class="n">swap_chain</span><span class="p">],</span> <span class="n">swap_map</span><span class="p">[</span><span class="n">swap_chain</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">swap_map</span><span class="p">[</span><span class="n">swap_chain</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">swap_map</span><span class="p">[</span><span class="n">swap_chain</span><span class="p">]</span>
            <span class="n">a_yes</span><span class="p">[</span><span class="n">cm</span><span class="o">.</span><span class="n">idx_PT</span><span class="p">,</span><span class="n">swap_chain</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">#a_yes[0,swap_chain]+=1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a_no</span><span class="p">[</span><span class="n">cm</span><span class="o">.</span><span class="n">idx_PT</span><span class="p">,</span><span class="n">swap_chain</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">#a_no[0,swap_chain]+=1</span>

    <span class="c1">#loop through the chains and record the new samples and log_Ls</span>
    <span class="n">FLIs_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x0s_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fisher_diag_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fisher_diag</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">):</span>
        <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">swap_map</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">itrb</span><span class="p">,:]</span>
        <span class="n">fisher_diag_new</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">fisher_diag</span><span class="p">[</span><span class="n">swap_map</span><span class="p">[</span><span class="n">j</span><span class="p">],:]</span>
        <span class="n">log_likelihood</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrb</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="p">[</span><span class="n">swap_map</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">itrb</span><span class="p">]</span>
        <span class="n">FLIs_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FLIs</span><span class="p">[</span><span class="n">swap_map</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
        <span class="n">x0s_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x0s</span><span class="p">[</span><span class="n">swap_map</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

    <span class="n">fisher_diag</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fisher_diag_new</span>
    <span class="n">FLIs</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="n">FLIs_new</span><span class="p">)</span>
    <span class="n">x0s</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="n">x0s_new</span><span class="p">)</span></div>
<span class="c1">#@njit()</span>
<span class="c1">#def do_pt_swap(n_chain, samples, itrb, Ts, a_yes, a_no, x0s, FLIs, log_likelihood,fisher_diag):</span>
<span class="c1">#    &quot;&quot;&quot;do the parallel tempering swap&quot;&quot;&quot;</span>
<span class="c1">#    #print(&quot;PT&quot;)</span>
<span class="c1">#</span>
<span class="c1">#    #print(&quot;PT&quot;)</span>
<span class="c1">#</span>
<span class="c1">#    #set up map to help keep track of swaps</span>
<span class="c1">#    swap_map = list(range(n_chain))</span>
<span class="c1">#</span>
<span class="c1">#    #get log_Ls from all the chains</span>
<span class="c1">#    log_Ls = []</span>
<span class="c1">#    for j in range(n_chain):</span>
<span class="c1">#        log_Ls.append(log_likelihood[j,itrb])</span>
<span class="c1">#</span>
<span class="c1">#    target_shuffle = np.random.permutation(np.arange(0,n_chain))</span>
<span class="c1">#</span>
<span class="c1">#    targets = np.zeros(n_chain,dtype=np.int64)</span>
<span class="c1">#    targets[target_shuffle[:n_chain//2]] = target_shuffle[n_chain//2:n_chain]</span>
<span class="c1">#    targets[target_shuffle[n_chain//2:n_chain]] = target_shuffle[:n_chain//2]</span>
<span class="c1">#</span>
<span class="c1">#    #loop through and propose a swap at each chain (starting from hottest chain and going down in T) and keep track of results in swap_map</span>
<span class="c1">#    #for swap_chain in reversed(range(n_chain-1)):</span>
<span class="c1">#    #for swap_chain in range(n_chain-2, -1, -1):  # same as reversed(range(n_chain-1)) but supported in numba</span>
<span class="c1">#    #    assert swap_map[swap_chain] == swap_chain</span>
<span class="c1">#    for itrt in range(0,n_chain):</span>
<span class="c1">#        itrt_target = targets[itrt]</span>
<span class="c1">#        if itrt&gt;itrt_target:</span>
<span class="c1">#            continue</span>
<span class="c1">#</span>
<span class="c1">#        assert swap_map[itrt] == itrt</span>
<span class="c1">#        assert swap_map[itrt_target] == itrt_target</span>
<span class="c1">#</span>
<span class="c1">#        log_acc_ratio = -log_Ls[itrt] / Ts[itrt]</span>
<span class="c1">#        log_acc_ratio += -log_Ls[itrt_target] / Ts[itrt_target]</span>
<span class="c1">#        log_acc_ratio += log_Ls[itrt_target] / Ts[itrt]</span>
<span class="c1">#        log_acc_ratio += log_Ls[itrt] / Ts[itrt_target]</span>
<span class="c1">#</span>
<span class="c1">#        acc_decide = np.log(uniform(0.0, 1.0, 1))</span>
<span class="c1">#        if acc_decide&lt;=log_acc_ratio:# and do_PT:</span>
<span class="c1">#            swap_map[itrt], swap_map[itrt_target] = swap_map[itrt_target], swap_map[itrt]</span>
<span class="c1">#            #if np.abs(itrt_target-itrt)==1:</span>
<span class="c1">#            if Ts[itrt_target]!=Ts[itrt]:</span>
<span class="c1">#                a_yes[cm.idx_PT,itrt] += 1</span>
<span class="c1">#                a_yes[cm.idx_PT,itrt_target] += 1</span>
<span class="c1">#            #a_yes[0,swap_chain]+=1</span>
<span class="c1">#        else:</span>
<span class="c1">#            #if np.abs(itrt_target-itrt)==1:</span>
<span class="c1">#            if Ts[itrt_target]!=Ts[itrt]:</span>
<span class="c1">#                a_no[cm.idx_PT,itrt] += 1</span>
<span class="c1">#                a_no[cm.idx_PT,itrt_target] += 1</span>
<span class="c1">#            #a_no[0,swap_chain]+=1</span>
<span class="c1">#</span>
<span class="c1">#    #loop through the chains and record the new samples and log_Ls</span>
<span class="c1">#    FLIs_new = []</span>
<span class="c1">#    x0s_new = []</span>
<span class="c1">#    fisher_diag_new = np.zeros_like(fisher_diag)</span>
<span class="c1">#    for j in range(n_chain):</span>
<span class="c1">#        samples[j,itrb+1,:] = samples[swap_map[j],itrb,:]</span>
<span class="c1">#        fisher_diag_new[j,:] = fisher_diag[swap_map[j],:]</span>
<span class="c1">#        log_likelihood[j,itrb+1] = log_likelihood[swap_map[j],itrb]</span>
<span class="c1">#        FLIs_new.append(FLIs[swap_map[j]])</span>
<span class="c1">#        x0s_new.append(x0s[swap_map[j]])</span>
<span class="c1">#</span>
<span class="c1">#    fisher_diag[:] = fisher_diag_new</span>
<span class="c1">#    FLIs[:] = List(FLIs_new)</span>
<span class="c1">#    x0s[:] = List(x0s_new)</span>

<div class="viewcode-block" id="add_rn_eig_starting_point"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.add_rn_eig_starting_point">[docs]</a><span class="k">def</span> <span class="nf">add_rn_eig_starting_point</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">chain_params</span><span class="p">,</span><span class="n">Npsr</span><span class="p">,</span><span class="n">FPI</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;add a fisher eig jump to the starting point of each chain based only on the fisher matrix at the first point&quot;&quot;&quot;</span>
    <span class="n">eig_rn0</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">get_fishers</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span> <span class="n">FLI_swap</span><span class="p">,</span>\
                              <span class="n">get_diag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">get_rn_block</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_common</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">scaling</span> <span class="o">=</span> <span class="mf">0.</span><span class="o">*</span><span class="mf">2.38</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Npsr</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
        <span class="n">scale_eig0</span> <span class="o">=</span> <span class="n">scaling</span><span class="o">*</span><span class="n">eig_rn0</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">scale_eig1</span> <span class="o">=</span> <span class="n">scaling</span><span class="o">*</span><span class="n">eig_rn0</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_rn_eig_jump</span><span class="p">(</span><span class="n">scale_eig0</span><span class="p">,</span><span class="n">scale_eig1</span><span class="p">,</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn</span><span class="p">],</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn</span><span class="p">,</span><span class="n">Npsr</span><span class="p">)</span>
        <span class="c1">#correct intrinsic just in case</span>
        <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_intrinsic</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">chain_params</span><span class="o">.</span><span class="n">freq_bounds</span><span class="p">,</span><span class="n">FPI</span><span class="o">.</span><span class="n">cut_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">cut_lows</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">cut_highs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples</span></div>


<div class="viewcode-block" id="initialize_de_buffer"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.initialize_de_buffer">[docs]</a><span class="k">def</span> <span class="nf">initialize_de_buffer</span><span class="p">(</span><span class="n">sample0</span><span class="p">,</span><span class="n">n_par_tot</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">chain_params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FPI</span><span class="p">,</span><span class="n">eig_rn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;set up differential evolution&quot;&quot;&quot;</span>
    <span class="n">de_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span> <span class="n">chain_params</span><span class="o">.</span><span class="n">de_history_size</span><span class="p">,</span> <span class="n">n_par_tot</span><span class="p">))</span>

    <span class="c1">#initialize the rn parameters to the starting point plus a fisher matrix jump</span>
    <span class="n">idx_rn</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn</span>
    <span class="n">scaling</span> <span class="o">=</span> <span class="mf">2.38</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">Npsr</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">rn_base</span> <span class="o">=</span> <span class="n">sample0</span><span class="p">[</span><span class="n">idx_rn</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
        <span class="n">scale_eig0</span> <span class="o">=</span> <span class="n">scaling</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">chain_params</span><span class="o">.</span><span class="n">Ts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">eig_rn</span><span class="p">[</span><span class="n">j</span><span class="p">,:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="n">scale_eig1</span> <span class="o">=</span> <span class="n">scaling</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">chain_params</span><span class="o">.</span><span class="n">Ts</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">eig_rn</span><span class="p">[</span><span class="n">j</span><span class="p">,:,</span><span class="mi">1</span><span class="p">,:]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chain_params</span><span class="o">.</span><span class="n">de_history_size</span><span class="p">):</span>
            <span class="n">new_point</span> <span class="o">=</span> <span class="n">CWFastPrior</span><span class="o">.</span><span class="n">get_sample_full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">par_names</span><span class="p">),</span><span class="n">FPI</span><span class="p">)</span>

            <span class="c1">#reset the red noise parameters to be a fisher matrix jump off of the starting values</span>
            <span class="n">new_point</span> <span class="o">=</span> <span class="n">add_rn_eig_jump</span><span class="p">(</span><span class="n">scale_eig0</span><span class="p">,</span><span class="n">scale_eig1</span><span class="p">,</span><span class="n">new_point</span><span class="p">,</span><span class="n">rn_base</span><span class="p">,</span><span class="n">idx_rn</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">Npsr</span><span class="p">)</span>

            <span class="c1">#do corrections just in case</span>
            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span>
            <span class="n">new_point</span> <span class="o">=</span> <span class="n">correct_intrinsic</span><span class="p">(</span><span class="n">new_point</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">chain_params</span><span class="o">.</span><span class="n">freq_bounds</span><span class="p">,</span><span class="n">FPI</span><span class="o">.</span><span class="n">cut_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">cut_lows</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">cut_highs</span><span class="p">)</span>
            <span class="n">new_point</span> <span class="o">=</span> <span class="n">correct_extrinsic</span><span class="p">(</span><span class="n">new_point</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="n">de_history</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">new_point</span>
    <span class="k">return</span> <span class="n">de_history</span></div>

<div class="viewcode-block" id="initialize_sample_helper"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.initialize_sample_helper">[docs]</a><span class="k">def</span> <span class="nf">initialize_sample_helper</span><span class="p">(</span><span class="n">chain_params</span><span class="p">,</span><span class="n">n_par_tot</span><span class="p">,</span><span class="n">Npsr</span><span class="p">,</span><span class="n">max_toa</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">par_names_cw_ext</span><span class="p">,</span><span class="n">par_names_cw_int</span><span class="p">,</span><span class="n">FPI</span><span class="p">,</span><span class="n">pta</span><span class="p">,</span><span class="n">noisedict</span><span class="p">,</span><span class="n">rn_emp_dist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;initialize starting samples for each chain to a random point&quot;&quot;&quot;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span> <span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_par_tot</span><span class="p">))</span>
    <span class="c1">#samples_load = np.load(&#39;samples_final_wde_respace3.npy&#39;)</span>
    <span class="c1">#samples_load = np.load(&#39;samples_final_node18.npy&#39;)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
        <span class="c1">#samples[j,0,:] = np.array([par.sample() for par in pta.params])</span>
        <span class="c1">#if j&lt;samples_load.shape[0]:</span>
        <span class="c1">#samples[j,0,:] = samples_load[j]#samples_load[j%min(samples_load.shape[0],5)]</span>
        <span class="c1">#acceptable_initial_samples = True</span>
        <span class="c1">#else:</span>
        <span class="n">acceptable_initial_samples</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#acceptable_initial_samples = False</span>

        <span class="n">itr_accept</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">acceptable_initial_samples</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">itr_accept</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;failed to find acceptable initial sample&#39;</span><span class="p">)</span>
            <span class="c1">#samples[j,0,:] = np.array([CWFastPrior.get_sample_helper(i, FPI.uniform_par_ids, FPI.uniform_lows, FPI.uniform_highs,</span>
            <span class="c1">#                                                            FPI.lin_exp_par_ids, FPI.lin_exp_lows, FPI.lin_exp_highs,</span>
            <span class="c1">#                                                            FPI.normal_par_ids, FPI.normal_mus, FPI.normal_sigs) for i in range(len(par_names))])</span>
            <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">CWFastPrior</span><span class="o">.</span><span class="n">get_sample_full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">par_names</span><span class="p">),</span><span class="n">FPI</span><span class="p">)</span>
            <span class="c1">#do correct intrinsic and correct extrinsic just in case</span>
            <span class="k">if</span> <span class="n">itr_accept</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">x0_swap</span> <span class="o">=</span> <span class="n">CWFastLikelihoodNumba</span><span class="o">.</span><span class="n">CWInfo</span><span class="p">(</span><span class="n">Npsr</span><span class="p">,</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">par_names</span><span class="p">,</span><span class="n">par_names_cw_ext</span><span class="p">,</span><span class="n">par_names_cw_int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>

            <span class="k">for</span> <span class="n">psr</span> <span class="ow">in</span> <span class="n">pta</span><span class="o">.</span><span class="n">pulsars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">chain_params</span><span class="o">.</span><span class="n">zero_rn</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zero_rn=True --&gt; Setting &quot;</span> <span class="o">+</span> <span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_gamma=0.0&quot;</span><span class="p">)</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_gamma&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">elif</span> <span class="n">rn_emp_dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">psr_idx</span> <span class="o">=</span> <span class="n">pta</span><span class="o">.</span><span class="n">pulsars</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span><span class="p">)</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_gamma&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rn_emp_dist</span><span class="p">[</span><span class="n">psr_idx</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#print(samples[j,0,par_names.index(psr + &quot;_red_noise_gamma&quot;)])</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_gamma&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">noisedict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_gamma&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">noisedict</span><span class="p">[</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_gamma&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No value found in noisedict for: &quot;</span> <span class="o">+</span> <span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_gamma&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using a random draw from the prior as a first sample instead&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_gamma&quot;</span><span class="p">)])</span>

                <span class="k">if</span> <span class="n">chain_params</span><span class="o">.</span><span class="n">zero_rn</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zero_rn=True --&gt; Setting &quot;</span> <span class="o">+</span> <span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_log10_A=-20.0&quot;</span><span class="p">)</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_log10_A&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">20.0</span>
                <span class="k">elif</span> <span class="n">rn_emp_dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">psr_idx</span> <span class="o">=</span> <span class="n">pta</span><span class="o">.</span><span class="n">pulsars</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span><span class="p">)</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_log10_A&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">rn_emp_dist</span><span class="p">[</span><span class="n">psr_idx</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1">#print(samples[j,0,par_names.index(psr + &quot;_red_noise_log10_A&quot;)])</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_log10_A&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">noisedict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_log10_A&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">noisedict</span><span class="p">[</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_log10_A&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No value found in noisedict for: &quot;</span> <span class="o">+</span> <span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_log10_A&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting it to a low value of -19 to help convergence of insignificant RN&quot;</span><span class="p">)</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_log10_A&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">19.0</span>

            <span class="k">if</span> <span class="n">chain_params</span><span class="o">.</span><span class="n">zero_gwb</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zero_gwb=True --&gt; Setting gwb_gamma=0.0&quot;</span><span class="p">)</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;gwb_gamma&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">elif</span> <span class="s2">&quot;gwb_gamma&quot;</span> <span class="ow">in</span> <span class="n">noisedict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;gwb_gamma&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">noisedict</span><span class="p">[</span><span class="s2">&quot;gwb_gamma&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No value found in noisedict for: gwb_gamma&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using a random draw from the prior as a first sample instead&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">chain_params</span><span class="o">.</span><span class="n">zero_gwb</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zero_gwb=True --&gt; Setting gwb_log10_A=-20.0&quot;</span><span class="p">)</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;gwb_log10_A&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">20.0</span>
            <span class="k">elif</span> <span class="s2">&quot;gwb_log10_A&quot;</span> <span class="ow">in</span> <span class="n">noisedict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;gwb_log10_A&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">noisedict</span><span class="p">[</span><span class="s2">&quot;gwb_log10_A&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No value found in noisedict for: gwb_log10_A&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting it to a low value of -19 to help convergence of insignificant RN&quot;</span><span class="p">)</span>
                <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;gwb_log10_A&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">19.0</span>

            <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">correct_intrinsic</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:],</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">chain_params</span><span class="o">.</span><span class="n">freq_bounds</span><span class="p">,</span><span class="n">FPI</span><span class="o">.</span><span class="n">cut_par_ids</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">cut_lows</span><span class="p">,</span> <span class="n">FPI</span><span class="o">.</span><span class="n">cut_highs</span><span class="p">)</span>
            <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">correct_extrinsic</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:],</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="c1">#check the maximum toa is not such that the source has already merged, and if so draw new parameters to avoid starting from nan likelihood</span>
            <span class="n">acceptable_initial_samples</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">check_merged</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;0_log10_fgw&quot;</span><span class="p">)],</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;0_log10_mc&quot;</span><span class="p">)],</span><span class="n">max_toa</span><span class="p">)</span>
            <span class="n">itr_accept</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">samples</span></div>

<div class="viewcode-block" id="get_param_names"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.get_param_names">[docs]</a><span class="k">def</span> <span class="nf">get_param_names</span><span class="p">(</span><span class="n">pta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get the name Lists for various parameters&quot;&quot;&quot;</span>
    <span class="n">par_names</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="n">pta</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
    <span class="n">par_names_cw</span> <span class="o">=</span> <span class="n">List</span><span class="p">([</span><span class="s1">&#39;0_cos_gwtheta&#39;</span><span class="p">,</span> <span class="s1">&#39;0_cos_inc&#39;</span><span class="p">,</span> <span class="s1">&#39;0_gwphi&#39;</span><span class="p">,</span> <span class="s1">&#39;0_log10_fgw&#39;</span><span class="p">,</span> <span class="s1">&#39;0_log10_h&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;0_log10_mc&#39;</span><span class="p">,</span> <span class="s1">&#39;0_phase0&#39;</span><span class="p">,</span> <span class="s1">&#39;0_psi&#39;</span><span class="p">])</span>
    <span class="n">par_names_cw_ext</span> <span class="o">=</span> <span class="n">List</span><span class="p">([</span><span class="s1">&#39;0_cos_inc&#39;</span><span class="p">,</span> <span class="s1">&#39;0_log10_h&#39;</span><span class="p">,</span> <span class="s1">&#39;0_phase0&#39;</span><span class="p">,</span> <span class="s1">&#39;0_psi&#39;</span><span class="p">])</span>
    <span class="n">par_names_cw_int</span> <span class="o">=</span> <span class="n">List</span><span class="p">([</span><span class="s1">&#39;0_cos_gwtheta&#39;</span><span class="p">,</span> <span class="s1">&#39;0_gwphi&#39;</span><span class="p">,</span> <span class="s1">&#39;0_log10_fgw&#39;</span><span class="p">,</span> <span class="s1">&#39;0_log10_mc&#39;</span><span class="p">])</span>

    <span class="n">par_names_noise</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gwb_gamma&#39;</span><span class="p">,</span> <span class="s1">&#39;gwb_log10_A&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">psr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pta</span><span class="o">.</span><span class="n">pulsars</span><span class="p">):</span>
        <span class="n">par_names_cw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_cw0_p_dist&quot;</span><span class="p">)</span>
        <span class="n">par_names_cw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_cw0_p_phase&quot;</span><span class="p">)</span>
        <span class="n">par_names_cw_ext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_cw0_p_phase&quot;</span><span class="p">)</span>
        <span class="n">par_names_cw_int</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_cw0_p_dist&quot;</span><span class="p">)</span>
        <span class="n">par_names_noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_gamma&quot;</span><span class="p">)</span>
        <span class="n">par_names_noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psr</span> <span class="o">+</span> <span class="s2">&quot;_red_noise_log10_A&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">par_names</span><span class="p">,</span><span class="n">par_names_cw</span><span class="p">,</span><span class="n">par_names_cw_int</span><span class="p">,</span><span class="n">par_names_cw_ext</span><span class="p">,</span><span class="n">par_names_noise</span></div>

<div class="viewcode-block" id="ChainParams"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.ChainParams">[docs]</a><span class="k">class</span> <span class="nc">ChainParams</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;store basic parameters the govern the evolution of the mcmc chain&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n_chain</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_block_status_update</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n_int_block</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
                 <span class="n">n_update_fisher</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100_000</span><span class="p">,</span> <span class="n">save_every_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
                 <span class="n">fisher_eig_downsample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">T_ladder</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">includeCW</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">prior_recovery</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">freq_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">gwb_comps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
                 <span class="n">cos_gwtheta_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">gwphi_bounds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]),</span>
                 <span class="n">de_history_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5_000</span><span class="p">,</span> <span class="n">thin_de</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
                 <span class="n">log_fishers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">log_mean_likelihoods</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">savefile</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">thin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">samples_precision</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">,</span>
                 <span class="n">save_first_n_chains</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">prior_draw_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">de_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">fisher_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
                 <span class="n">rn_emp_dist_file</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">dist_jump_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">rn_jump_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">gwb_jump_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                 <span class="n">common_jump_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
                 <span class="n">all_jump_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
                 <span class="n">fix_rn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">zero_rn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">fix_gwb</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">zero_gwb</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">n_int_block</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n_int_block</span> <span class="o">&gt;=</span> <span class="mi">4</span>  <span class="c1"># need to have n_int block&gt;=4 a multiple of 2</span>
        <span class="c1"># in order to always do at least n*(1 extrinsic+1 pt swap)+(1 intrinsic+1 pt swaps)</span>
        <span class="k">assert</span> <span class="n">save_every_n</span> <span class="o">%</span> <span class="n">n_int_block</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># or we won&#39;t save</span>
        <span class="k">assert</span> <span class="n">n_update_fisher</span> <span class="o">%</span> <span class="n">n_int_block</span> <span class="o">==</span> <span class="mi">0</span>  <span class="c1"># or we won&#39;t update fisher</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span> <span class="o">=</span> <span class="n">n_chain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span> <span class="o">=</span> <span class="n">n_int_block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_update_fisher</span> <span class="o">=</span> <span class="n">n_update_fisher</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_every_n</span> <span class="o">=</span> <span class="n">save_every_n</span>
        <span class="c1">#multiplier for how much less to do more expensive updates to fisher eigendirections for red noise and common parameters compared to diagonal elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_eig_downsample</span> <span class="o">=</span> <span class="n">fisher_eig_downsample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_update_fisher_eig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_update_fisher</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher_eig_downsample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_max</span> <span class="o">=</span> <span class="n">T_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ladder</span> <span class="o">=</span> <span class="n">T_ladder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">includeCW</span> <span class="o">=</span> <span class="n">includeCW</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior_recovery</span> <span class="o">=</span> <span class="n">prior_recovery</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="n">verbosity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq_bounds</span> <span class="o">=</span> <span class="n">freq_bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gwb_comps</span> <span class="o">=</span> <span class="n">gwb_comps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cos_gwtheta_bounds</span><span class="o">=</span><span class="n">cos_gwtheta_bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gwphi_bounds</span><span class="o">=</span><span class="n">gwphi_bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">de_history_size</span> <span class="o">=</span> <span class="n">de_history_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thin_de</span> <span class="o">=</span> <span class="n">thin_de</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_fishers</span> <span class="o">=</span> <span class="n">log_fishers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_mean_likelihoods</span> <span class="o">=</span> <span class="n">log_mean_likelihoods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rn_emp_dist_file</span> <span class="o">=</span> <span class="n">rn_emp_dist_file</span>

        <span class="k">if</span> <span class="n">T_ladder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#using geometric spacing</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_max</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ts</span> <span class="o">=</span> <span class="n">c</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using </span><span class="si">{0}</span><span class="s2"> temperature chains with a geometric spacing of </span><span class="si">{1:.3f}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">Temperature ladder is:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span><span class="n">c</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">Ts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">T_ladder</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ts</span><span class="o">.</span><span class="n">size</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using </span><span class="si">{0}</span><span class="s2"> temperature chains with custom spacing: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">Ts</span><span class="p">)</span>

        <span class="c1">#store the set of parameters which are allowed to change between calls to advance_N_blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_block_status_update</span> <span class="o">=</span> <span class="n">n_block_status_update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">savefile</span> <span class="o">=</span> <span class="n">savefile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thin</span> <span class="o">=</span> <span class="n">thin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_precision</span> <span class="o">=</span> <span class="n">samples_precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_first_n_chains</span> <span class="o">=</span> <span class="n">save_first_n_chains</span>

        <span class="c1">#jump type probabilities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior_draw_prob</span> <span class="o">=</span> <span class="n">prior_draw_prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">de_prob</span> <span class="o">=</span> <span class="n">de_prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_prob</span> <span class="o">=</span> <span class="n">fisher_prob</span>

        <span class="c1">#rn switches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zero_rn</span> <span class="o">=</span> <span class="n">zero_rn</span>
        <span class="c1">#also fix rn if it&#39;s set to be zero</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_rn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fix_rn</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fix_rn</span> <span class="o">=</span> <span class="n">fix_rn</span>

        <span class="c1">#gwb switches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zero_gwb</span> <span class="o">=</span> <span class="n">zero_gwb</span>
        <span class="c1">#also fix gwb if it&#39;s set to be zero</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_gwb</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fix_gwb</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fix_gwb</span> <span class="o">=</span> <span class="n">fix_gwb</span>

        <span class="c1">#jump parameter set probabilities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_jump_weight</span> <span class="o">=</span> <span class="n">dist_jump_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">common_jump_weight</span> <span class="o">=</span> <span class="n">common_jump_weight</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_rn</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Overwrite rn_jump_weight to 0, due to fix_rn=True.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rn_jump_weight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rn_jump_weight</span> <span class="o">=</span> <span class="n">rn_jump_weight</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_gwb</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Overwrite gwb_jump_weight to 0, due to fix_gwb=True.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gwb_jump_weight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gwb_jump_weight</span> <span class="o">=</span> <span class="n">gwb_jump_weight</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_gwb</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_rn</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Overwrite all_jump_weight to 0, due to either fix_rn or fix_gwb being True.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_jump_weight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_jump_weight</span> <span class="o">=</span> <span class="n">all_jump_weight</span>

        <span class="c1">#jump parameters to control number of eigendirections</span>
        <span class="c1">#TODO make these actual arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_ext_directions</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_phase_extra</span> <span class="o">=</span> <span class="mi">16</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_dist_extra</span> <span class="o">=</span> <span class="mi">67</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_dist_main</span> <span class="o">=</span> <span class="mi">67</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_noise_emp_dist</span> <span class="o">=</span> <span class="mi">20</span><span class="c1">#5#3#1#30#67#1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">big_de_jump_prob</span> <span class="o">=</span> <span class="mf">0.5</span></div>


<div class="viewcode-block" id="MCMCChain"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.MCMCChain">[docs]</a><span class="k">class</span> <span class="nc">MCMCChain</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;store the miscellaneous objects needed to manage the mcmc chain&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">chain_params</span><span class="p">,</span><span class="n">psrs</span><span class="p">,</span><span class="n">pta</span><span class="p">,</span><span class="n">max_toa</span><span class="p">,</span><span class="n">noisedict</span><span class="p">,</span><span class="n">ti</span><span class="p">):</span>
        <span class="c1">#set up fast likelihoods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span> <span class="o">=</span> <span class="n">chain_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ti</span> <span class="o">=</span> <span class="n">ti</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">includeCW</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">includeCW</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior_recovery</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">prior_recovery</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_toa</span> <span class="o">=</span> <span class="n">max_toa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_chain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pta</span> <span class="o">=</span> <span class="n">pta</span>
        <span class="c1">#gte parameter names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_int</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_ext</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_noise</span> <span class="o">=</span> <span class="n">get_param_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pta</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_par_tot</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_int_block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_update_fisher</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_update_fisher</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psrs</span> <span class="o">=</span> <span class="n">psrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Npsr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pta</span><span class="o">.</span><span class="n">pulsars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noisedict</span> <span class="o">=</span> <span class="n">noisedict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">verbosity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">itri</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag_logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_eig_logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_common_logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_likelihoods</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_likelihoods</span> <span class="o">=</span> <span class="p">[]</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">FPI</span> <span class="o">=</span> <span class="n">CWFastPrior</span><span class="o">.</span><span class="n">get_FastPriorInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">psrs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_ext</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;uniform &#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">uniform_par_ids</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;normal &#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">normal_par_ids</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;lin exp &#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">lin_exp_par_ids</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dm dist &#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">dm_par_ids</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;px dist &#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">px_par_ids</span><span class="p">)</span>

        <span class="c1">#assert np.all(FPI.cw_ext_lows==cw_ext_lows)</span>
        <span class="c1">#assert np.all(FPI.cw_ext_highs==cw_ext_highs)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">cw_ext_lows</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">cw_ext_highs</span><span class="p">)</span>

        <span class="c1">#read in RN empirical distribution files if provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">rn_emp_dist_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reading in RN empirical distributions...&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">rn_emp_dist_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rn_emp_dist</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="c1">#create a temperature adapted empirical distribution</span>
            <span class="c1">#self.rn_emp_dist_adapt = []</span>
            <span class="c1">#for j,T in enumerate(self.chain_params.Ts):</span>
            <span class="c1">#    emp_dist_loc = []</span>
            <span class="c1">#    for emp_dist0 in self.rn_emp_dist:</span>
            <span class="c1">#        emp_dist_loc.append(TemperatureAdaptedEmpiricalDistribution(emp_dist0,T))</span>

            <span class="c1">#    self.rn_emp_dist_adapt.append(emp_dist_loc)</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rn_emp_dist</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1">#self.rn_emp_dist_adapt = None</span>

        <span class="c1">#set up samples array</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting up first sample at </span><span class="si">%8.3f</span><span class="s2">s...&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">initialize_sample_helper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_par_tot</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Npsr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">max_toa</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_ext</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_int</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">noisedict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rn_emp_dist</span><span class="p">)</span>


        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_prior=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">CWFastPrior</span><span class="o">.</span><span class="n">get_lnprior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="p">)))</span>

        <span class="c1">#set up log_likelihood array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating Shared Info Objects at </span><span class="si">%8.3f</span><span class="s2">s&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">ti</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span> <span class="o">=</span> <span class="n">CWFastLikelihoodNumba</span><span class="o">.</span><span class="n">CWInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Npsr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_ext</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_int</span><span class="p">)</span>
        <span class="c1">#TODO why was this distance zeroing here? Shouldn&#39;t change from initialized state</span>
        <span class="c1">#self.samples[:,0,self.x0_swap.idx_dists] = 0.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">flm</span> <span class="o">=</span> <span class="n">CWFastLikelihoodNumba</span><span class="o">.</span><span class="n">FastLikeMaster</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psrs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pta</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:])),</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="p">,</span>
                                                        <span class="n">includeCW</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">includeCW</span><span class="p">,</span><span class="n">prior_recovery</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prior_recovery</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flm</span><span class="o">.</span><span class="n">get_new_FastLike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:])))</span>

        <span class="c1">#add a random fisher eigenvalue jump to the starting point for the j&gt;0 chains to get more diversity in the initial fisher matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">add_rn_eig_starting_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flm</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Npsr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x0s</span> <span class="o">=</span> <span class="n">List</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span>  <span class="o">=</span> <span class="n">List</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">CWFastLikelihoodNumba</span><span class="o">.</span><span class="n">CWInfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Npsr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_ext</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_int</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flm</span><span class="o">.</span><span class="n">get_new_FastLike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]))))</span>

        <span class="c1">#make extra x0s to help parallelizing MTMCMC updates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0_extras</span> <span class="o">=</span> <span class="n">List</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">n_x0_extra</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0_extras</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CWFastLikelihoodNumba</span><span class="o">.</span><span class="n">CWInfo</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pta</span><span class="o">.</span><span class="n">pulsars</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_ext</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names_cw_int</span><span class="p">))</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished Creating Shared Info Objects at </span><span class="si">%8.3f</span><span class="s2">s&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dist_prior_sigmas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dist_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">idx_dists</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dist_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">normal_par_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist_prior_sigmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">normal_sigs</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">normal_par_ids</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dist_idx</span><span class="p">)])</span>
            <span class="k">elif</span> <span class="n">dist_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">dm_par_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist_prior_sigmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">dm_errs</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">dm_par_ids</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dist_idx</span><span class="p">)])</span>
            <span class="k">elif</span> <span class="n">dist_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">px_par_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist_prior_sigmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">px_errs</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">px_par_ids</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dist_idx</span><span class="p">)]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">px_mus</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="o">.</span><span class="n">px_par_ids</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dist_idx</span><span class="p">)]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dist_prior_sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_prior_sigmas</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Distance prior sigmas calculated for fisher correction:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_prior_sigmas</span><span class="p">)</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Geting Starting Fishers at </span><span class="si">%8.3f</span><span class="s2">s&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span>
        <span class="c1">#get only the starting point so we can add a fisher red noise jump to the others</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="c1">#don&#39;t bother getting common eigenvectors for the starting positions because they probably aren&#39;t at a maximum; will use defaults instead</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_rn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_common</span> <span class="o">=</span> <span class="n">get_fishers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_sel</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="p">,</span>\
                                                                   <span class="n">get_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_rn_block</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_common</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag_next2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_rn_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_rn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_common_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_common</span><span class="p">)</span>
        <span class="c1">#chose the indices of parameters where fisher matrix diagonals will next be computed so they can be stored before they are erased if n_update_fisher is larger than n_int_block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_update_fisher</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">)</span><span class="c1">#np.zeros(self.n_chain,dtype=np.int64)</span>

        <span class="c1">#chose the indices of parameters where fisher matrix eigenvalues will next be computed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next_eig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next_eig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_update_fisher_eig</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">)</span><span class="c1">#np.zeros(self.n_chain,dtype=np.int64)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_eig_logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_rn</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag_logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher_common_logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_common</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished Getting Starting Fishers at </span><span class="si">%8.3f</span><span class="s2">s&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">de_history</span> <span class="o">=</span> <span class="n">initialize_de_buffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">n_par_tot</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_rn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished Setting up Differential Evolution Buffer at </span><span class="si">%8.3f</span><span class="s2">s&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_yes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">32</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">32</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acc_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_yes</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_no</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">a_yes</span><span class="p">)</span>

        <span class="c1">#printing info about initial parameters</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;chain #&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_likelihood=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_prior_old=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pta</span><span class="o">.</span><span class="n">get_lnprior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;log_prior_new=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">CWFastPrior</span><span class="o">.</span><span class="n">get_lnprior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:],</span><span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial samples:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>

        <span class="c1">#for j in range(self.n_chain):</span>
        <span class="c1">#    print(&quot;j=&quot;+str(j))</span>
        <span class="c1">#    print(self.samples[j,0,:])</span>
        <span class="c1">#    #log_likelihood[j,0] = pta.get_lnlikelihood(samples[j,0,:])</span>
        <span class="c1">#    self.log_likelihood[j,0] = self.FLIs[j].get_lnlikelihood(self.x0s[j])</span>
        <span class="c1">#    print(&quot;log_likelihood=&quot;+str(self.log_likelihood[j,0]))</span>
        <span class="c1">#    print(&quot;log_prior=&quot;+str(CWFastPrior.get_lnprior(self.samples[j,0,:], self.FPI)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># check things were initialized as expected</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_logL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">best_logL_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_logL_global</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[</span><span class="n">best_logL_idx</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_sample_global</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">best_logL_idx</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tf_init</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;finished initialization steps in </span><span class="si">%8.3f</span><span class="s2">s&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tf_init</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ti_loop</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tf1_loop</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
    <span class="c1">#@profile</span>
<div class="viewcode-block" id="MCMCChain.advance_block"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.MCMCChain.advance_block">[docs]</a>    <span class="k">def</span> <span class="nf">advance_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;advance the state of the mcmc chain by 1 entire block, updating fisher matrices and differential evolution as necessary&quot;&quot;&quot;</span>
        <span class="n">itrn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">itri</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span>  <span class="c1"># index overall</span>
        <span class="n">itrb</span> <span class="o">=</span> <span class="n">itrn</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span>  <span class="c1"># index within the block of saved values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">itrb</span><span class="p">)</span>  <span class="c1"># check FLIs and x0s appear to have internally consistent parameters</span>
        <span class="c1">#always do pt steps in extrinsic</span>
        <span class="n">do_extrinsic_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">itrb</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">Ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FPI</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_par_tot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_yes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_no</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_fishers_partial</span><span class="p">(</span><span class="n">itrn</span><span class="p">,</span><span class="n">itrn</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">#update intrinsic parameters once a block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span> <span class="o">=</span> <span class="n">do_intrinsic_update_mt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">full_validate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># check FLIs and x0s appear to have internally consistent parameters</span>

        <span class="n">do_pt_swap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span> <span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">Ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_yes</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">a_no</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_fishers_partial</span><span class="p">(</span><span class="n">itrn</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">itrn</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_de_history</span><span class="p">(</span><span class="n">itrn</span><span class="p">)</span> <span class="c1">#update de history array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_fishers</span><span class="p">(</span><span class="n">itrn</span><span class="p">)</span> <span class="c1">#do fisher updates as necessary</span>


        <span class="c1">#update acceptance rate</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">acc_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_yes</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_no</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">a_yes</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">itri</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tf1_loop</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>

        <span class="c1">#update best ever found likelihood</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_logL</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_logL</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">Ts</span><span class="o">==</span><span class="mf">1.</span><span class="p">,:]))</span>
        <span class="n">best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">best_logL_global_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[</span><span class="n">best_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">best_logL_global_loc</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">best_logL_global</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;new best global sample old logL=</span><span class="si">%+12.3f</span><span class="s2"> new logL=</span><span class="si">%+12.3f</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_logL_global</span><span class="p">,</span><span class="n">best_logL_global_loc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_logL_global</span> <span class="o">=</span> <span class="n">best_logL_global_loc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_sample_global</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">best_idx</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;local index of global best is&quot;</span><span class="p">,</span><span class="n">best_idx</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;new best params&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">best_sample_global</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">itri</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">log_mean_likelihoods</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mean_likelihoods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,</span><span class="n">itrb</span><span class="p">:</span><span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_likelihoods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,</span><span class="n">itrb</span><span class="p">:</span><span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">itrb</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mean likelihoods&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_likelihoods</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;best likelihood anywhere in latest block&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">max_likelihoods</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

        <span class="c1">#check that there are no large decreases in log likelihood</span>
        <span class="c1">#if itrn&gt;self.chain_params.save_every_n and np.any(np.diff(self.log_likelihood[:,:itrb+self.n_int_block],axis=1)&lt;-300.):</span>
        <span class="k">if</span> <span class="n">itrn</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,:</span><span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">&lt;-</span><span class="mf">300.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">Ts</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,:</span><span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,:</span><span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,:</span><span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,:</span><span class="n">itrb</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">&lt;-</span><span class="mf">300.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">Ts</span> <span class="p">))</span>
            <span class="k">assert</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="MCMCChain.update_de_history"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.MCMCChain.update_de_history">[docs]</a>    <span class="k">def</span> <span class="nf">update_de_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">itrn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;update de history array&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
            <span class="n">n_de_update</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">thin_de</span>
            <span class="k">for</span> <span class="n">itrd</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_de_update</span><span class="p">):</span>
                <span class="n">itrbd</span> <span class="o">=</span> <span class="n">itrn</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span><span class="o">+</span><span class="n">itrd</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">thin_de</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrbd</span><span class="p">,:]</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">de_history</span><span class="p">[</span><span class="n">j</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">itri</span><span class="o">*</span><span class="n">n_de_update</span><span class="o">+</span><span class="n">itrd</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">de_history_size</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">itrbd</span><span class="p">,:]</span></div>

<div class="viewcode-block" id="MCMCChain.update_fishers_partial"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.MCMCChain.update_fishers_partial">[docs]</a>    <span class="k">def</span> <span class="nf">update_fishers_partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">itrn1</span><span class="p">,</span><span class="n">itrn2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;handle fisher matrix update logic, itrn1 and itrn2 must be ranges over which no changes in the total set of intrinsic parameters occur</span>
<span class="sd">        so that we can skip the intrinsic update&quot;&quot;&quot;</span>
        <span class="c1">#put each new fisher matrix into action as soon as possible after it is available, also breaks up any special behavior at common reset points</span>
        <span class="c1">#note that the random shuffling in update_fishers also makes it so that there is a finite probability any particular fisher matrix is kept for more than 1 block</span>
        <span class="n">itrb1</span> <span class="o">=</span> <span class="n">itrn1</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span>
        <span class="n">itrb2</span> <span class="o">=</span> <span class="n">itrb1</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">itrn2</span><span class="o">-</span><span class="n">itrn1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">itrb2</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">itrb2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">eig_sel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">eig_sel</span><span class="p">:</span>
                    <span class="n">idx_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next_eig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">idx_loc_mod</span> <span class="o">=</span> <span class="n">idx_loc</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span>

                <span class="c1">#need to handle the specific case where the chosen sample is the very last one in a block to be saved</span>
                <span class="c1">#because the samples array actually has size save_every_n+1, not save_every_n</span>
                <span class="c1">#alternatively, could just let the next loop around handle this case, but this gets the new fisher 1 block sooner</span>
                <span class="k">if</span> <span class="n">itrn1</span><span class="o">!=</span><span class="n">idx_loc</span> <span class="ow">and</span> <span class="n">idx_loc_mod</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">idx_loc_mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span>

                <span class="k">if</span> <span class="n">itrn1</span> <span class="o">&lt;=</span> <span class="n">idx_loc</span> <span class="o">&lt;</span> <span class="n">itrn2</span><span class="p">:</span>
                    <span class="c1">#find the posterior sample we need to calculate the fisher matrices at</span>
                    <span class="n">sample_need</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="n">idx_loc_mod</span><span class="p">:</span><span class="n">idx_loc_mod</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span>
                    <span class="c1">#find the FLI with the right intrinsic parameters</span>
                    <span class="n">found_match</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
                        <span class="n">sample_loc</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j2</span><span class="p">:</span><span class="n">j2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">itrb2</span><span class="p">:</span><span class="n">itrb2</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span>
                        <span class="k">if</span> <span class="n">itrb2</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j2</span><span class="p">:</span><span class="n">j2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">itrb2</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">itrb2</span><span class="o">+</span><span class="mi">2</span><span class="p">,:]</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sample_need</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_int</span><span class="p">]</span> <span class="o">==</span> <span class="n">sample_loc</span><span class="p">[:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_int</span><span class="p">]):</span>
                            <span class="c1">#print(&quot;start found&quot;,j,j2,itrn1,itrn2,idx_loc,idx_end_mod,eig_sel)</span>
                            <span class="c1">#print(sample_loc[0,0,self.x0_swap.idx_cw_int])</span>
                            <span class="n">found_match</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">if</span> <span class="n">eig_sel</span><span class="p">:</span>
                                <span class="c1">#the intrinsic and rn all match, so we should be able to evaluate the fisher diagonals from this FLI without a full intrinsic update on FLI_swap</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">sample_need</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>
                                <span class="n">eig_rn_loc</span><span class="p">,</span><span class="n">fisher_diag_loc</span><span class="p">,</span><span class="n">eig_common_loc</span> <span class="o">=</span> <span class="n">get_fishers</span><span class="p">(</span><span class="n">sample_need</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j2</span><span class="p">],</span>\
                                                                                        <span class="n">get_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_common</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_rn_block</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">start_safe</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">eig_rn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">eig_rn_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">eig_common</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">eig_common_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_diag_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="k">continue</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1">#the intrinsic and rn all match, so we should be able to evaluate the fisher diagonals from this FLI without a full intrinsic update on FLI_swap</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">sample_need</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>
                                <span class="n">_</span><span class="p">,</span><span class="n">fisher_diag_loc</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">get_fishers</span><span class="p">(</span><span class="n">sample_need</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j2</span><span class="p">],</span>\
                                                                  <span class="n">get_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_common</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">get_rn_block</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">start_safe</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                <span class="c1">#assign the extrinsic parameters to the next diagonal</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_cw_ext</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_diag_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_cw_ext</span><span class="p">]</span>
                                <span class="k">continue</span>
                    <span class="k">assert</span> <span class="n">found_match</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">itrb2</span><span class="p">)</span></div>


<div class="viewcode-block" id="MCMCChain.validate_consistent"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.MCMCChain.validate_consistent">[docs]</a>    <span class="k">def</span> <span class="nf">validate_consistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">itrb</span><span class="p">,</span><span class="n">full_validate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
            <span class="c1">#print(&#39;j2&#39;,j3)</span>
            <span class="c1">#print(self.FLIs[j3].get_lnlikelihood(self.x0s[j3]),self.log_likelihood[j3,itrb])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="n">j3</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j3</span><span class="p">,</span><span class="n">itrb</span><span class="p">])</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="n">j3</span><span class="p">])</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[</span><span class="n">j3</span><span class="p">,</span><span class="n">itrb</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">full_validate</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j3</span><span class="p">,</span><span class="n">itrb</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flm</span><span class="o">.</span><span class="n">recompute_FastLike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j3</span><span class="p">,</span><span class="n">itrb</span><span class="p">])))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="n">j3</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">j3</span><span class="p">,</span><span class="n">itrb</span><span class="p">])</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_base</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">logdet_base</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">logdet</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">resres</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">resres_array</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">MMs</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">MMs</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">NN</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">NN</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">itrp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Npsr</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">chol_Sigmas</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="n">j3</span><span class="p">]</span><span class="o">.</span><span class="n">chol_Sigmas</span><span class="p">[</span><span class="n">itrp</span><span class="p">])</span></div>


<div class="viewcode-block" id="MCMCChain.update_fishers"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.MCMCChain.update_fishers">[docs]</a>    <span class="k">def</span> <span class="nf">update_fishers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">itrn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;handle fisher matrix update logic&quot;&quot;&quot;</span>
        <span class="c1">#choose which parameter indexes to get for future fisher matrix evaluation points</span>
        <span class="c1">#the actual fisher update logic is done as soon as possible in update_fishers_partial</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">itrn</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">itrn</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span><span class="p">,:]</span>

            <span class="k">if</span> <span class="n">itrn</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next_eig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">itrn</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next_eig</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next_eig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span><span class="p">,:]</span>


        <span class="k">if</span> <span class="n">itrn</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">n_update_fisher</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">itri</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1">#prevent a terrible red noise fisher matrix from messing up one temperature for a very long time</span>
            <span class="c1">#by randomly shuffling the fisher matrices between chains whenever we do diagonal updates</span>
            <span class="n">shuffle_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eig_rn</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_rn</span><span class="p">[</span><span class="n">shuffle_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eig_common</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_common</span><span class="p">[</span><span class="n">shuffle_idx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">[</span><span class="n">shuffle_idx</span><span class="p">]</span>

            <span class="c1">#compute fisher matrix at random recent points in the posterior</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">):</span>
                <span class="c1">#eigenvalue update takes precedence over diagonal update parameters as it happens less frequently</span>
                <span class="k">if</span> <span class="n">itrn</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_update_fisher_eig</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next_eig</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next_eig</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
                    <span class="c1">#choose the next point to select</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next_eig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">itrn</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_update_fisher_eig</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next_eig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">==</span><span class="mf">0.</span><span class="p">)</span>
                    <span class="c1">#load in the previous selected point</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>

                <span class="c1">#choose the next point to select</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">idx_fisher_sel_next</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">itrn</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_update_fisher</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples_sel_next</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">log_fishers</span><span class="p">:</span>
                <span class="c1">#optionally log the old fisher matrices for diagnostic purposes, they dont really take much memory</span>
                <span class="k">if</span> <span class="n">itrn</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_update_fisher_eig</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag_logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fisher_eig_logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_rn</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fisher_common_logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_common</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#update only the extrinsic fisher diagonals in this case</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag_logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="n">itrb</span> <span class="o">=</span> <span class="n">itrn</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">itrb</span><span class="p">)</span>  <span class="c1"># check FLIs and x0s appear to have internally consistent parameters</span></div>


<div class="viewcode-block" id="MCMCChain.do_status_update"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.MCMCChain.do_status_update">[docs]</a>    <span class="k">def</span> <span class="nf">do_status_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">itrn</span><span class="p">,</span><span class="n">N_blocks</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;print a status update&quot;&quot;&quot;</span>
        <span class="n">t_itr</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">print_acceptance_progress</span><span class="p">(</span><span class="n">itrn</span><span class="p">,</span><span class="n">N_blocks</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">a_yes</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">a_no</span><span class="p">,</span><span class="n">t_itr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">ti_loop</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">tf1_loop</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">Ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_likelihoods</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">mean_likelihood</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_likelihoods</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">Ts</span><span class="o">==</span><span class="mf">1.</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean_likelihood</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;New log_L=</span><span class="si">%+12.3f</span><span class="s2"> Mean T=1 last block=</span><span class="si">%+12.3f</span><span class="s2"> Best T=1 log_L=</span><span class="si">%+12.3f</span><span class="s2"> best overall log_L=</span><span class="si">%+12.3f</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FLIs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0s</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">mean_likelihood</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">best_logL</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">best_logL_global</span><span class="p">))</span><span class="c1">#,FLIs[0].resres,FLIs[0].logdet,FLIs[0].pos,FLIs[0].pdist,FLIs[0].NN,FLIs[0].MMs)))</span></div>
        <span class="c1">#itrb = itrn%self.chain_params.save_every_n #index within the block of saved values</span>
        <span class="c1">#print(itrb)</span>
        <span class="c1">#print(self.samples[0,itrb,:])</span>
        <span class="c1">#print(&quot;Old log_L=%+12.3f&quot;%(self.pta.get_lnlikelihood(self.samples[0,itrb,:])))</span>

<div class="viewcode-block" id="MCMCChain.output_and_wrap_state"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.MCMCChain.output_and_wrap_state">[docs]</a>    <span class="k">def</span> <span class="nf">output_and_wrap_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">itrn</span><span class="p">,</span><span class="n">N_blocks</span><span class="p">,</span><span class="n">do_output</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;wrap the samples around to the first element and save the old ones to the hdf5 file&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">do_output</span><span class="p">:</span>
            <span class="n">output_hdf5_loop</span><span class="p">(</span><span class="n">itrn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">acc_fraction</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="n">N_blocks</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span><span class="p">)</span>

        <span class="c1">#clear out log_likelihood and samples arrays</span>
        <span class="n">samples_now</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="n">log_likelihood_now</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_par_tot</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">samples_now</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_likelihood_now</span></div>

<div class="viewcode-block" id="MCMCChain.advance_N_blocks"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickMCMCUtils.MCMCChain.advance_N_blocks">[docs]</a>    <span class="k">def</span> <span class="nf">advance_N_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">N_blocks</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;advance the state of the MCMC system by N_blocks of size&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_first_n_chains</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_chain</span> <span class="c1">#or we would try to save more chains than we have</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Entering Loop Body at </span><span class="si">%8.3f</span><span class="s2">s&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_blocks</span><span class="p">):</span>
            <span class="c1">#itrn = i*self.n_int_block #index overall</span>
            <span class="n">itrn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">itri</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span> <span class="c1">#index overall</span>
            <span class="n">itrb</span> <span class="o">=</span> <span class="n">itrn</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">save_every_n</span> <span class="c1">#index within the block of saved values</span>
            <span class="k">if</span> <span class="n">itrb</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">itri</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_and_wrap_state</span><span class="p">(</span><span class="n">itrn</span><span class="p">,</span><span class="n">N_blocks</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">itri</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="o">.</span><span class="n">n_block_status_update</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">do_status_update</span><span class="p">(</span><span class="n">itrn</span><span class="p">,</span><span class="n">N_blocks</span><span class="p">)</span>


            <span class="c1">#advance the block state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance_block</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">do_status_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">itri</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_int_block</span><span class="p">,</span><span class="n">N_blocks</span><span class="p">)</span>

        <span class="n">output_hdf5_end</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chain_params</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">log_likelihood</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">acc_fraction</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher_diag</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">par_names</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span><span class="p">)</span>
        <span class="n">tf</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;whole function time = </span><span class="si">%8.3f</span><span class="s1"> s&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">tf</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loop time = </span><span class="si">%8.3f</span><span class="s1"> s&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">tf</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ti_loop</span><span class="p">))</span></div></div>


<span class="c1">#class TemperatureAdaptedEmpiricalDistribution():</span>
<span class="c1">#    &quot;&quot;&quot;object to adapt a 2d empirical distribution from enterprise to a specific temperature&quot;&quot;&quot;</span>
<span class="c1">#    def __init__(self,rn_emp_dist0,T):</span>
<span class="c1">#        self.rn_emp_dist0 = rn_emp_dist0</span>
<span class="c1">#        self.T = T</span>
<span class="c1">#        self._edges = self.rn_emp_dist0._edges.copy()</span>
<span class="c1">#        self._wids = self.rn_emp_dist0._wids.copy()</span>
<span class="c1">#        self._Nbins = self.rn_emp_dist0._Nbins.copy()</span>
<span class="c1">#        area = np.outer(*self._wids)</span>
<span class="c1">#</span>
<span class="c1">#        self._pdf = (self.rn_emp_dist0._pdf.copy())**(1./max(1,T)) #raise pdf to a power</span>
<span class="c1">#        self._cdf = np.cumsum((self._pdf*area).ravel())</span>
<span class="c1">#</span>
<span class="c1">#        #need to adapt cdf and pdf to take into account correct normalization</span>
<span class="c1">#        self.renorm = self._cdf[-1]</span>
<span class="c1">#        self._pdf /= self.renorm</span>
<span class="c1">#        self._cdf /= self.renorm</span>
<span class="c1">#</span>
<span class="c1">#        self._logpdf = np.log(self._pdf)</span>
<span class="c1">#</span>
<span class="c1">#    def draw(self):</span>
<span class="c1">#        &quot;&quot;&quot;copied from enterprise_extensions&quot;&quot;&quot;</span>
<span class="c1">#        draw = np.random.rand()</span>
<span class="c1">#        draw_bin = np.searchsorted(self._cdf, draw)</span>
<span class="c1">#        idx = np.unravel_index(draw_bin, self._Nbins)</span>
<span class="c1">#        samp = [self._edges[ii, idx[ii]] + self._wids[ii, idx[ii]]*np.random.rand()</span>
<span class="c1">#                                for ii in range(2)]</span>
<span class="c1">#        return np.array(samp)</span>
<span class="c1">#</span>
<span class="c1">#    def prob(self, params):</span>
<span class="c1">#        &quot;&quot;&quot;copied from enterprise_extensions&quot;&quot;&quot;</span>
<span class="c1">#        ix, iy = [np.searchsorted(self._edges[ii], params[ii]) - 1 for ii in range(2)]</span>
<span class="c1">#</span>
<span class="c1">#        return self._pdf[ix, iy]</span>
<span class="c1">#</span>
<span class="c1">#    def logprob(self, params):</span>
<span class="c1">#        &quot;&quot;&quot;copied from enterprise_extensions&quot;&quot;&quot;</span>
<span class="c1">#        ix, iy = [np.searchsorted(self._edges[ii], params[ii]) - 1 for ii in range(2)]</span>
<span class="c1">#        return self._logpdf[ix, iy]</span>
<span class="c1">#</span>
<span class="c1">#    def get_emp_dist_T_ladder(self):</span>
<span class="c1">#        emp_dist0 = mcc.rn_emp_dist</span>
<span class="c1">#        pdf0 = emp_dist0.pdf_</span>
<span class="c1">#        for j,T in enumerate(self.chain_params.Ts):</span>
<span class="c1">#            pdfT = pdf0**(1./T) #raise pdf to power beta</span>
<span class="c1">#</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Bence Becsy, Neil Cornish, Matthew Digman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>