<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>QuickCW.QuickFisherHelpers &mdash; QuickCW  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            QuickCW
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">QuickCW</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">QuickCW.QuickFisherHelpers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for QuickCW.QuickFisherHelpers</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;C 2021 Bence Becsy</span>
<span class="sd">MCMC for CW fast likelihood (w/ Neil Cornish and Matthew Digman)</span>
<span class="sd">Helpers to get fisher matrices&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">QuickCW.const_mcmc</span> <span class="k">as</span> <span class="nn">cm</span>

<div class="viewcode-block" id="get_FLI_mem"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.get_FLI_mem">[docs]</a><span class="k">def</span> <span class="nf">get_FLI_mem</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;store everything needed to reset FLI for non-red noise updates</span>

<span class="sd">    :param FLI_swap:</span>
<span class="sd">    FastLikelihoodInfo object</span>

<span class="sd">    :return:</span>
<span class="sd">    Tuple with following elements:</span>
<span class="sd">                MMs0:               list of M matrices</span>
<span class="sd">                NN0:                list of N vectors</span>
<span class="sd">                resres_array0:      array with resres values</span>
<span class="sd">                logdet_array0:      array with logdet contributions</span>
<span class="sd">                logdet_base_old:    base value of logdet</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MMs0</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">MMs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">NN0</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">NN</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">resres_array0</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">logdet_array0</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">logdet_base_old</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_base</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">MMs0</span><span class="p">,</span><span class="n">NN0</span><span class="p">,</span><span class="n">resres_array0</span><span class="p">,</span><span class="n">logdet_array0</span><span class="p">,</span><span class="n">logdet_base_old</span><span class="p">)</span></div>

<div class="viewcode-block" id="params_perturb_helper"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.params_perturb_helper">[docs]</a><span class="k">def</span> <span class="nf">params_perturb_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">idxs_targ</span><span class="p">,</span><span class="n">epsilons</span><span class="p">,</span><span class="n">dist_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">phase_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper to perturb the specified parameters by factors of epsilon en masse</span>

<span class="sd">    :param params:</span>
<span class="sd">    array of parameter values</span>
<span class="sd">    :param x0_swap:</span>
<span class="sd">    CWInfo object</span>
<span class="sd">    :param FLI_swap:</span>
<span class="sd">    FastLikelihoodInfo object</span>
<span class="sd">    :param flm:</span>
<span class="sd">    FastLikeMaster object</span>
<span class="sd">    :param par_names:</span>
<span class="sd">    List of parameter names</span>
<span class="sd">    :param idxs_targ:</span>
<span class="sd">    Indices of parameters to be perturbed</span>
<span class="sd">    :param epsilon:</span>
<span class="sd">    Amount of perturbation</span>
<span class="sd">    :param dist_mode:</span>
<span class="sd">    Specify if pulsar distances are being perturbed [False]</span>
<span class="sd">    :param phase_mode:</span>
<span class="sd">    Specify if phases are being perturbed [False]</span>
<span class="sd">    :param mask:</span>
<span class="sd">    Mask to specify which pulsars need to be updated [None]</span>
<span class="sd">    If None, all pulsars are updated</span>

<span class="sd">    :return paramsPP:</span>
<span class="sd">    Perturbed parameters</span>
<span class="sd">    :return FLI_memp:</span>
<span class="sd">    FastLikeInfo object for the perturbed parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">paramsPP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">paramsPP</span><span class="p">[</span><span class="n">idxs_targ</span><span class="p">]</span> <span class="o">+=</span> <span class="n">epsilons</span>

    <span class="n">FLI_mem0</span> <span class="o">=</span> <span class="n">get_FLI_mem</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">)</span>

    <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsPP</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dist_mode</span><span class="p">:</span>
        <span class="c1">#logdets and resres don&#39;t need to be updated for distances</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">update_pulsar_distances</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">Npsr</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">phase_mode</span><span class="p">:</span>
        <span class="c1">#none of the matrices need to be updated for phases</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">flm</span><span class="o">.</span><span class="n">recompute_FastLike</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">par_names</span><span class="p">,</span> <span class="n">paramsPP</span><span class="p">)),</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;failed to perturb parameters for fisher&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;params: &quot;</span><span class="p">,</span><span class="n">paramsPP</span><span class="p">)</span>
            <span class="c1">#this will probably cause this particular fisher value to be invalid/not useful, but shouldn&#39;t be a huge issue in the long run</span>
            <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>


    <span class="n">FLI_memp</span> <span class="o">=</span> <span class="n">get_FLI_mem</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">)</span>

    <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">paramsPP</span><span class="p">,</span><span class="n">FLI_memp</span><span class="c1">#,paramsMM,MMsm,NNm,resres_arraym,logdet_arraym</span></div>

<span class="c1">#@njit()</span>
<div class="viewcode-block" id="fisher_synthetic_FLI_helper"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.fisher_synthetic_FLI_helper">[docs]</a><span class="k">def</span> <span class="nf">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_RR</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params_old</span><span class="p">,</span><span class="n">dist_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">phase_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper to construct synthetic likelihoods for each pulsar from input MMs and NNs one by one</span>

<span class="sd">    :param helper_tuple_RR:</span>

<span class="sd">    :param x0_swap:</span>
<span class="sd">    CWInfo object</span>
<span class="sd">    :param FLI_swap:</span>
<span class="sd">    FastLikelihoodInfo object</span>
<span class="sd">    :param params_old:</span>

<span class="sd">    :param dist_mode:</span>

<span class="sd">    :param phase_mode:</span>


<span class="sd">    :return rrs:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">paramsRR</span><span class="p">,</span><span class="n">FLI_memr</span><span class="p">)</span> <span class="o">=</span> <span class="n">helper_tuple_RR</span>
    <span class="p">(</span><span class="n">MMsr</span><span class="p">,</span><span class="n">NNr</span><span class="p">,</span><span class="n">resres_arrayr</span><span class="p">,</span><span class="n">logdet_arrayr</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">FLI_memr</span>
    <span class="n">rrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">Npsr</span><span class="p">)</span>
    <span class="c1">#isolate elements that change for maximum numerical accuracy</span>
    <span class="n">FLI_mem0</span> <span class="o">=</span> <span class="n">get_FLI_mem</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">)</span>

    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">MMs</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">NN</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>

    <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsRR</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">Npsr</span><span class="p">):</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">MMs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">MMsr</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">NN</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">NNr</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">resres_arrayr</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">logdet_arrayr</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dist_mode</span><span class="p">:</span>
            <span class="c1">#turn off all elements which do not vary with distance</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">MMs</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">NN</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">phase_mode</span><span class="p">:</span>
            <span class="c1">#turn off all elements which do not vary with phase</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">MMs</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">NN</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>

        <span class="c1">#all other contributions are 0 by construction</span>
        <span class="n">rrs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>

        <span class="c1">#reset elements to 0</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">MMs</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">NN</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>

    <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params_old</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rrs</span><span class="c1">#,fisher_diag</span></div>



<span class="c1">################################################################################</span>
<span class="c1">#</span>
<span class="c1">#CALCULATE RN FISHER EIGENVECTORS</span>
<span class="c1">#</span>
<span class="c1">################################################################################</span>
<div class="viewcode-block" id="get_fishers"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.get_fishers">[docs]</a><span class="k">def</span> <span class="nf">get_fishers</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">par_names</span><span class="p">,</span> <span class="n">x0_swap</span><span class="p">,</span> <span class="n">flm</span><span class="p">,</span> <span class="n">FLI_swap</span><span class="p">,</span><span class="n">get_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_common</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_rn_block</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">start_safe</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get all the red noise eigenvectors in a block, and if get_diag is True also get all the diagonal fisher matrix elements</span>

<span class="sd">    :param samples:</span>
<span class="sd">    Array of samples</span>
<span class="sd">    :param par_names:</span>
<span class="sd">    List of parameter names</span>
<span class="sd">    :param x0_swap:</span>
<span class="sd">    CWInfo object</span>
<span class="sd">    :param flm:</span>
<span class="sd">    FastLikeMaster object</span>
<span class="sd">    :param FLI_swap:</span>
<span class="sd">    FastLikeInfo object</span>
<span class="sd">    :param get_diag:</span>

<span class="sd">    :param get_common:</span>

<span class="sd">    :param get_rn_block:</span>

<span class="sd">    :param get_intrinsic_diag:</span>

<span class="sd">    :param start_safe:</span>

<span class="sd">    </span>
<span class="sd">    :return eig_rn:</span>

<span class="sd">    :return fisher_diag:</span>

<span class="sd">    :return eig_common:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#logdet_base is not needed for anything so turn it off, will revert later.</span>
    <span class="n">n_chain</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Npsr</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">Npsr</span>
    <span class="n">eig_rn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_chain</span><span class="p">,</span><span class="n">Npsr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">fisher_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_chain</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">par_names</span><span class="p">)))</span>
    <span class="n">eig_common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_chain</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="n">logdet_array_in</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">start_safe</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">itrc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">itrc</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">x0_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">itrc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">itrc</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_intrinsic_diag</span> <span class="ow">or</span> <span class="n">get_diag</span> <span class="ow">or</span> <span class="n">get_common</span><span class="p">:</span>
            <span class="c1">#as currently structure need diagonal data for get_fisher_eigenvectors_common</span>
            <span class="n">fisher_diag</span><span class="p">[</span><span class="n">itrc</span><span class="p">,:],</span><span class="n">diagonal_data_loc</span> <span class="o">=</span> <span class="n">get_fisher_diagonal</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">par_names</span><span class="p">,</span>  <span class="n">x0_swap</span><span class="p">,</span> <span class="n">flm</span><span class="p">,</span> <span class="n">FLI_swap</span><span class="p">,</span><span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="n">get_intrinsic_diag</span><span class="p">,</span><span class="n">start_safe</span><span class="o">=</span><span class="n">start_safe</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_safe</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">logdet_array_in</span><span class="o">==</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">)</span>
            <span class="c1">#pp1s,mm1s,nn1s,epsilons,helper_tuple0,pps,mms,nns = diagonal_data_loc</span>
            <span class="k">if</span> <span class="n">get_intrinsic_diag</span> <span class="ow">or</span> <span class="n">get_common</span><span class="p">:</span>
                <span class="n">eig_common</span><span class="p">[</span><span class="n">itrc</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_fisher_eigenvectors_common</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">x0_swap</span><span class="p">,</span> <span class="n">FLI_swap</span><span class="p">,</span> <span class="n">diagonal_data_loc</span><span class="p">,</span><span class="n">default_all</span><span class="o">=</span><span class="ow">not</span> <span class="n">get_common</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_safe</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">logdet_array_in</span><span class="o">==</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">get_rn_block</span><span class="p">:</span>
            <span class="c1">#fisher_diag = np.zeros(len(par_names))</span>
            <span class="n">epsilon_gammas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="s1">&#39;red_noise_gamma&#39;</span><span class="p">]</span>
            <span class="n">epsilon_log10_As</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="s1">&#39;red_noise_log10_A&#39;</span><span class="p">]</span>

            <span class="c1">#adapt epsilon to be a bit bigger at low amplitude values</span>
            <span class="n">epsilon_gammas</span><span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cm</span><span class="o">.</span><span class="n">eps_log10_A_small_cut</span><span class="p">]</span> <span class="o">*=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps_rn_diag_gamma_small_mult</span>
            <span class="n">epsilon_log10_As</span><span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cm</span><span class="o">.</span><span class="n">eps_log10_A_small_cut</span><span class="p">]</span> <span class="o">*=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps_rn_diag_log10_A_small_mult</span>

            <span class="c1">#don&#39;t need gwb because it doesn&#39;t affect the eigenvectors</span>
            <span class="n">pp1s</span><span class="p">,</span><span class="n">mm1s</span><span class="p">,</span><span class="n">nn1s</span><span class="p">,</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">fisher_rn_mm_pp_diagonal_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">epsilon_gammas</span><span class="p">,</span><span class="n">epsilon_log10_As</span><span class="p">,</span><span class="n">Npsr</span><span class="p">,</span><span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">start_safe</span><span class="o">=</span><span class="n">start_safe</span><span class="p">,</span><span class="n">get_gwb</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_safe</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">logdet_array_in</span><span class="o">==</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">)</span>

            <span class="n">pps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">par_names</span><span class="p">))</span>
            <span class="n">mms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">par_names</span><span class="p">))</span>
            <span class="n">nns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">par_names</span><span class="p">))</span>
            <span class="n">epsilons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">par_names</span><span class="p">))</span>
            <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon_gammas</span>
            <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon_log10_As</span>
            <span class="n">diagonal_data_loc</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp1s</span><span class="p">,</span><span class="n">mm1s</span><span class="p">,</span><span class="n">nn1s</span><span class="p">,</span><span class="n">epsilons</span><span class="p">,</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">pps</span><span class="p">,</span><span class="n">mms</span><span class="p">,</span><span class="n">nns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_rn_block</span><span class="p">:</span>
            <span class="n">eig_rn</span><span class="p">[</span><span class="n">itrc</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_fisher_rn_block_eigenvectors</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">par_names</span><span class="p">,</span> <span class="n">x0_swap</span><span class="p">,</span> <span class="n">flm</span><span class="p">,</span> <span class="n">FLI_swap</span><span class="p">,</span><span class="n">diagonal_data_loc</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_safe</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">logdet_array_in</span><span class="o">==</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">)</span>

            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">start_safe</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">logdet_array_in</span><span class="o">==</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">)</span>


    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start_safe</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">itrc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chain</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="n">itrc</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">x0_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">eig_rn</span><span class="p">,</span><span class="n">fisher_diag</span><span class="p">,</span><span class="n">eig_common</span></div>


<div class="viewcode-block" id="get_fisher_rn_block_eigenvectors"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.get_fisher_rn_block_eigenvectors">[docs]</a><span class="k">def</span> <span class="nf">get_fisher_rn_block_eigenvectors</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">par_names</span><span class="p">,</span> <span class="n">x0_swap</span><span class="p">,</span> <span class="n">flm</span><span class="p">,</span> <span class="n">FLI_swap</span><span class="p">,</span><span class="n">diagonal_data_loc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get the diagonal elements of the fisher matrix with the needed local stabilizations</span>

<span class="sd">    :param params:</span>

<span class="sd">    :param par_names:</span>
<span class="sd">    List of parameter names</span>
<span class="sd">    :param x0_swap:</span>
<span class="sd">    CWInfo object</span>
<span class="sd">    :param flm:</span>
<span class="sd">    FastLikeMaster object</span>
<span class="sd">    :param FLI_swap:</span>
<span class="sd">    FastLikeInfo object</span>
<span class="sd">    :param diagonal_data_loc:</span>


<span class="sd">    :return eig_rn:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Npsr</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">Npsr</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">#[0.8,0.25] is more reflective of center of distribution for poorly constrained rn parameters</span>
    <span class="c1">#but not really necessary to go out that far and it reduces acceptances</span>
    <span class="n">sigma_noise_defaults</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">])</span>
    <span class="c1">#eig_limit = 1./np.max(sigma_noise_defaults)**2#1.0#0.25</span>
    <span class="n">small_cut_mult</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">fisher_suppress</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="n">eig_limit</span> <span class="o">=</span> <span class="mf">4.</span>

    <span class="n">fisher_prod_lim</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">sigma_noise_defaults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma_noise_defaults</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">fisher_cut_lims</span> <span class="o">=</span> <span class="n">small_cut_mult</span><span class="o">*</span><span class="mf">1.</span><span class="o">/</span><span class="n">sigma_noise_defaults</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">determinant_cut</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">fisher_prod_lim</span>

    <span class="n">fisher</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Npsr</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
    <span class="n">pure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">Npsr</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="n">badc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Npsr</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">eig_rn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Npsr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="c1">#np.broadcast_to(np.eye(2)*0.5, (n_chain, Npsr, 2, 2) )#.copy()</span>

    <span class="c1">#future locations</span>
    <span class="n">pp1s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Npsr</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">mm1s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Npsr</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">pp2s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Npsr</span><span class="p">)</span>
    <span class="n">mm2s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Npsr</span><span class="p">)</span>
    <span class="n">pm2s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Npsr</span><span class="p">)</span>
    <span class="n">mp2s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Npsr</span><span class="p">)</span>

    <span class="n">pp1s</span><span class="p">,</span><span class="n">mm1s</span><span class="p">,</span><span class="n">nn1s</span><span class="p">,</span><span class="n">epsilons</span><span class="p">,</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">diagonal_data_loc</span>
    <span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span> <span class="o">=</span> <span class="n">helper_tuple0</span>

    <span class="n">chol_Sigmas_save</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npsr</span><span class="p">):</span>
        <span class="n">chol_Sigmas_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">chol_Sigmas</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="n">epsilon_diags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Npsr</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">epsilon_diags</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">]</span>
    <span class="n">epsilon_diags</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span>


    <span class="k">for</span> <span class="n">itrs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npsr</span><span class="p">):</span>
        <span class="c1">#calculate off-diagonal elements of the Hessian from a central finite element scheme</span>
        <span class="c1">#note the minus sign compared to the regular Hessian</span>
        <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
        <span class="c1">#calculate off-diagonal elements</span>

        <span class="k">for</span> <span class="n">itrp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="c1">#calculate diagonal elements of the Hessian from a central finite element scheme</span>
            <span class="c1">#note the minus sign compared to the regular Hessian</span>
            <span class="c1">#factor of 4 in the denominator is absorbed because pp1s and mm1s use 2*epsilon steps</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">pp1s</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">nn1s</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">+</span> <span class="n">mm1s</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="n">itrp</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">epsilon_diags</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span><span class="o">*</span><span class="n">epsilon_diags</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="n">itrp</span><span class="p">])</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="n">sigma_noise_defaults</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1">#patch to handle bad values</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">])</span> <span class="ow">or</span> <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">fisher_cut_lims</span><span class="p">[</span><span class="n">itrp</span><span class="p">]:</span>
                <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sigma_noise_defaults</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">badc</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">pure</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1">#if one value is bad and the other is small, assume we both were actually bad and default the whole matrix</span>
        <span class="k">if</span> <span class="n">badc</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">fisher_cut_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">fisher_cut_lims</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sigma_noise_defaults</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sigma_noise_defaults</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1">#if both values are small, scale the diagonals up so the product at the minimum to increase the chances of the eigenvectors being usable while mostly preserving the structure</span>
        <span class="k">if</span> <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">fisher_prod_lim</span><span class="p">:</span>
            <span class="n">holdmax</span> <span class="o">=</span> <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fisher_prod_lim</span><span class="o">/</span><span class="n">holdmax</span><span class="p">)</span>
            <span class="n">pure</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#track ones that defaulted so we can skip evalauation of the off diagonal element completely</span>
    <span class="c1">#because many default this can save non-trivial amounts of time</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of Pulsars with Fisher Eigenvectors in Full Default: &quot;</span><span class="p">,(</span><span class="n">badc</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span><span class="s2">&quot;Diagonal Default: &quot;</span><span class="p">,(</span><span class="n">badc</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span><span class="s2">&quot;No Default: &quot;</span><span class="p">,(</span><span class="n">badc</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="c1">#TODO temporary to test if we can recover better fishers</span>
    <span class="n">defaulted</span> <span class="o">=</span> <span class="n">badc</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="c1">#defaulted = badc == 2</span>
    <span class="c1">#defaulted[:] = False</span>

    <span class="c1">#the noise parameters are very expensive to calculate individually so calculate them all en masse</span>
    <span class="c1">#get the off diagonal elements of the fisher matrix</span>

    <span class="n">idx_rns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">])</span>
    <span class="n">epsilon_offdiag</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps_rn_offdiag</span>
    <span class="n">epsilon_drns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">idx_rns</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">+</span><span class="n">epsilon_offdiag</span>
    <span class="n">epsilon_crns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">idx_rns</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">-</span><span class="n">epsilon_offdiag</span> <span class="c1">#make idx_rn_log10_As negative and idx_rn_gammax positive</span>
    <span class="n">epsilon_crns</span><span class="p">[:</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon_offdiag</span>

    <span class="c1">#adapt epsilon to be a bit bigger at low amplitude values</span>
    <span class="n">epsilon_drns</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="o">.</span><span class="n">size</span><span class="p">][</span><span class="n">params</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cm</span><span class="o">.</span><span class="n">eps_log10_A_small_cut</span><span class="p">]</span> <span class="o">*=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps_rn_offdiag_small_mult</span>
    <span class="n">epsilon_drns</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="o">.</span><span class="n">size</span><span class="p">:][</span><span class="n">params</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cm</span><span class="o">.</span><span class="n">eps_log10_A_small_cut</span><span class="p">]</span> <span class="o">*=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps_rn_offdiag_small_mult</span>

    <span class="n">epsilon_crns</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="o">.</span><span class="n">size</span><span class="p">][</span><span class="n">params</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cm</span><span class="o">.</span><span class="n">eps_log10_A_small_cut</span><span class="p">]</span> <span class="o">*=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps_rn_offdiag_small_mult</span>
    <span class="n">epsilon_crns</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="o">.</span><span class="n">size</span><span class="p">:][</span><span class="n">params</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cm</span><span class="o">.</span><span class="n">eps_log10_A_small_cut</span><span class="p">]</span> <span class="o">*=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps_rn_offdiag_small_mult</span>

    <span class="n">helper_tuple_drns_PP</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">idx_rns</span><span class="p">,</span><span class="n">epsilon_drns</span><span class="p">,</span><span class="n">mask</span><span class="o">=~</span><span class="n">defaulted</span><span class="p">)</span>
    <span class="n">helper_tuple_drns_MM</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">idx_rns</span><span class="p">,</span><span class="o">-</span><span class="n">epsilon_drns</span><span class="p">,</span><span class="n">mask</span><span class="o">=~</span><span class="n">defaulted</span><span class="p">)</span>

    <span class="n">helper_tuple_crns_PM</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">idx_rns</span><span class="p">,</span><span class="n">epsilon_crns</span><span class="p">,</span><span class="n">mask</span><span class="o">=~</span><span class="n">defaulted</span><span class="p">)</span>
    <span class="n">helper_tuple_crns_MP</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">idx_rns</span><span class="p">,</span><span class="o">-</span><span class="n">epsilon_crns</span><span class="p">,</span><span class="n">mask</span><span class="o">=~</span><span class="n">defaulted</span><span class="p">)</span>

    <span class="c1">#the nns from the diagonal method should be derived safely as well as the PP, MM, PM, and MP here</span>
    <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

    <span class="n">pp2s</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_drns_PP</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
    <span class="n">mm2s</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_drns_MM</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>

    <span class="n">pm2s</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_crns_PM</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
    <span class="n">mp2s</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_crns_MP</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>

    <span class="c1">#update FLI_swap and x0_swap to at least a self consistent state</span>
    <span class="c1">#copy back in chol_Sigmas for safety</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npsr</span><span class="p">):</span>
        <span class="n">FLI_swap</span><span class="o">.</span><span class="n">chol_Sigmas</span><span class="p">[</span><span class="n">ii</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">chol_Sigmas_save</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

    <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>



    <span class="k">for</span> <span class="n">itrs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npsr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">defaulted</span><span class="p">[</span><span class="n">itrs</span><span class="p">]:</span>
            <span class="n">fisher_offdiag</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">pure</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fisher_offdiag</span> <span class="o">=</span>  <span class="o">-</span><span class="p">(</span><span class="n">pp2s</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">-</span> <span class="n">mp2s</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">-</span> <span class="n">pm2s</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">+</span> <span class="n">mm2s</span><span class="p">[</span><span class="n">itrs</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">epsilon_offdiag</span><span class="o">*</span><span class="n">epsilon_offdiag</span><span class="p">)</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fisher_offdiag</span><span class="p">):</span>
                <span class="k">assert</span> <span class="kc">False</span>
                <span class="n">fisher_offdiag</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1">#do not let the determinant be negative or 0 to ensure matrix is positive definite</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">fisher_offdiag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">determinant_cut</span><span class="p">:</span><span class="c1">#1./cm.sigma_noise_default**4:</span>
            <span class="n">pure</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">fisher_offdiag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">fisher_offdiag</span><span class="p">)</span><span class="o">*</span><span class="n">fisher_suppress</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">fisher_prod_lim</span><span class="p">))</span>

        <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fisher_offdiag</span><span class="p">):</span>
            <span class="k">assert</span> <span class="kc">False</span>
            <span class="n">pure</span><span class="p">[</span><span class="n">itrs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">fisher_offdiag</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_offdiag</span>
        <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1">#Filter nans and infs and replace them with 1s</span>
        <span class="c1">#this will imply that we will set the eigenvalue to 100 a few lines below</span>
        <span class="n">FISHER</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">]),</span> <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">FISHER</span><span class="p">,</span> <span class="n">fisher</span><span class="p">[</span><span class="n">itrs</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Changed some nan elements in the Fisher matrix to 1.0&quot;</span><span class="p">)</span>

        <span class="c1">#Find eigenvalues and eigenvectors of the Fisher matrix</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">FISHER</span><span class="p">)</span>

        <span class="c1">#filter w for eigenvalues smaller than 100 and set those to 100 -- Neil&#39;s trick</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">&gt;</span><span class="n">eig_limit</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">eig_limit</span><span class="p">)</span>

        <span class="n">rn_eigvec</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">W</span><span class="p">))</span><span class="o">*</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">eig_rn</span><span class="p">[</span><span class="n">itrs</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">rn_eigvec</span><span class="p">[:,:]</span>
    <span class="k">return</span> <span class="n">eig_rn</span></div>


<div class="viewcode-block" id="fisher_rn_mm_pp_diagonal_helper"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.fisher_rn_mm_pp_diagonal_helper">[docs]</a><span class="k">def</span> <span class="nf">fisher_rn_mm_pp_diagonal_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">epsilon_gammas</span><span class="p">,</span><span class="n">epsilon_log10_As</span><span class="p">,</span><span class="n">Npsr</span><span class="p">,</span><span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">start_safe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">get_gwb</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;helper to get the mm and pp values needed to calculate the diagonal fisher eigenvectors for the red noise parameters</span>

<span class="sd">    :param params:</span>

<span class="sd">    :param x0_swap:</span>
<span class="sd">    CWInfo object</span>
<span class="sd">    :param FLI_swap:</span>
<span class="sd">    FastLikeInfo object</span>
<span class="sd">    :param flm:</span>
<span class="sd">    FastLikeMaster object</span>
<span class="sd">    :param par_names:</span>
<span class="sd">    List of parameter names</span>
<span class="sd">    :param epsilon_gammas:</span>

<span class="sd">    :param epsilon_log10_As:</span>

<span class="sd">    :param Npsr:</span>
<span class="sd">    Number of pulsars</span>
<span class="sd">    :param get_intrinsic_diag:</span>

<span class="sd">    :param start_safe:</span>

<span class="sd">    :param get_gwb:</span>
<span class="sd">    </span>
<span class="sd">    :return pp1s:</span>

<span class="sd">    :return mm1s:</span>
<span class="sd">    </span>
<span class="sd">    :return nn1s:</span>

<span class="sd">    :return helper_tuple0:</span>

<span class="sd">    :return pps_gwb:</span>

<span class="sd">    :return mms_gwb:</span>

<span class="sd">    :return nns_gwb:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">get_intrinsic_diag</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating RN fisher Eigenvectors&quot;</span><span class="p">)</span>
    <span class="c1">#future locations</span>
    <span class="n">pp1s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Npsr</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">mm1s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Npsr</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">nns_gwb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">pps_gwb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">mms_gwb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="c1">#put the reset here to avoid having to do it both before and after</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">start_safe</span><span class="p">:</span>
        <span class="n">flm</span><span class="o">.</span><span class="n">recompute_FastLike</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">par_names</span><span class="p">,</span> <span class="n">params</span><span class="p">)))</span>

    <span class="n">FLI_mem0</span> <span class="o">=</span> <span class="n">get_FLI_mem</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">)</span>

    <span class="n">helper_tuple0</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>
    <span class="n">nn1s</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">get_intrinsic_diag</span><span class="p">:</span>
        <span class="c1">#save chol_Sigmas so everything can be reset to full self consistency</span>
        <span class="n">chol_Sigmas_save</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npsr</span><span class="p">):</span>
            <span class="n">chol_Sigmas_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">chol_Sigmas</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="c1">#the noise parameters are very expensive to calculate individually so calculate them all en masse</span>
        <span class="n">helper_tuple_gammas_PP</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">,</span><span class="n">epsilon_gammas</span><span class="p">)</span>
        <span class="n">helper_tuple_gammas_MM</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">,</span><span class="o">-</span><span class="n">epsilon_gammas</span><span class="p">)</span>

        <span class="n">helper_tuple_log10_As_PP</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">,</span><span class="n">epsilon_log10_As</span><span class="p">)</span>
        <span class="n">helper_tuple_log10_As_MM</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">,</span><span class="o">-</span><span class="n">epsilon_log10_As</span><span class="p">)</span>

        <span class="c1">#epsilon = cm.eps[&#39;red_noise_gamma&#39;]</span>
        <span class="n">pp1s</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_gammas_PP</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
        <span class="n">mm1s</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_gammas_MM</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>

        <span class="c1">#epsilon = cm.eps[&#39;red_noise_log10_A&#39;]</span>
        <span class="n">pp1s</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_log10_As_PP</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>
        <span class="n">mm1s</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_log10_As_MM</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_gwb</span><span class="p">:</span>
            <span class="c1">#double check everything is reset although it shouldn&#39;t actually be necessary here</span>
            <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

            <span class="c1">#copy back in chol_Sigmas for safety</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npsr</span><span class="p">):</span>
                <span class="n">FLI_swap</span><span class="o">.</span><span class="n">chol_Sigmas</span><span class="p">[</span><span class="n">ii</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">chol_Sigmas_save</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

            <span class="n">nns_gwb</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>

            <span class="c1">#do the gwb parameters</span>
            <span class="k">for</span> <span class="n">itr</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb</span><span class="p">):</span>
                <span class="c1">#gwb jump so update everything</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="n">par_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

                <span class="n">paramsPP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="n">paramsMM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

                <span class="n">paramsPP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>
                <span class="n">paramsMM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>


                <span class="c1">#must be one of the intrinsic parameters</span>
                <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsPP</span><span class="p">)</span>

                <span class="n">flm</span><span class="o">.</span><span class="n">recompute_FastLike</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">par_names</span><span class="p">,</span> <span class="n">paramsPP</span><span class="p">)),</span><span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">pps_gwb</span><span class="p">[</span><span class="n">itr</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span><span class="c1">#FLI_swap.resres,FLI_swap.logdet,FLI_swap.pos,FLI_swap.pdist,FLI_swap.NN,FLI_swap.MMs)</span>

                <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsMM</span><span class="p">)</span>

                <span class="n">flm</span><span class="o">.</span><span class="n">recompute_FastLike</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">par_names</span><span class="p">,</span> <span class="n">paramsMM</span><span class="p">)),</span><span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">mms_gwb</span><span class="p">[</span><span class="n">itr</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span><span class="c1">#,FLI_swap.resres,FLI_swap.logdet,FLI_swap.pos,FLI_swap.pdist,FLI_swap.NN,FLI_swap.MMs)</span>

                <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

                <span class="c1">#copy back in chol_Sigmas for safety</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npsr</span><span class="p">):</span>
                    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">chol_Sigmas</span><span class="p">[</span><span class="n">ii</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">chol_Sigmas_save</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

            <span class="c1">#copy back in chol_Sigmas for safety</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npsr</span><span class="p">):</span>
                <span class="n">FLI_swap</span><span class="o">.</span><span class="n">chol_Sigmas</span><span class="p">[</span><span class="n">ii</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">chol_Sigmas_save</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>

    <span class="c1">#double check everything is reset although it shouldn&#39;t actually be necessary here</span>
    <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pp1s</span><span class="p">,</span><span class="n">mm1s</span><span class="p">,</span><span class="n">nn1s</span><span class="p">,</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">pps_gwb</span><span class="p">,</span><span class="n">mms_gwb</span><span class="p">,</span><span class="n">nns_gwb</span></div>

<div class="viewcode-block" id="safe_reset_swap"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.safe_reset_swap">[docs]</a><span class="k">def</span> <span class="nf">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params_old</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;safely reset everything back to the initial values as input for self consistency in future calculations&quot;&quot;&quot;</span>
    <span class="n">MMs0</span><span class="p">,</span><span class="n">NN0</span><span class="p">,</span><span class="n">resres_array0</span><span class="p">,</span><span class="n">logdet_array0</span><span class="p">,</span><span class="n">logdet_base_old</span> <span class="o">=</span> <span class="n">FLI_mem0</span>
    <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params_old</span><span class="p">)</span>

    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">cos_gwtheta</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">cos_gwtheta</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">gwphi</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">gwphi</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">log10_fgw</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">log10_fgw</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">log10_mc</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">log10_mc</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">gwb_gamma</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">gwb_gamma</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">gwb_log10_A</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">gwb_log10_A</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">rn_gammas</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">rn_gammas</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">rn_log10_As</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">rn_log10_As</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">cw_p_dists</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">cw_p_dists</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">MMs</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">MMs0</span>
    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">NN</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">NN0</span>

    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">resres_array0</span><span class="p">,</span><span class="n">logdet_array0</span><span class="p">,</span><span class="n">logdet_base_old</span><span class="p">)</span>

    <span class="n">FLI_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
    <span class="n">x0_swap</span><span class="o">.</span><span class="n">validate_consistent</span><span class="p">(</span><span class="n">params_old</span><span class="p">)</span></div>

<span class="c1">################################################################################</span>
<span class="c1">#</span>
<span class="c1">#CALCULATE FISHER DIAGONAL</span>
<span class="c1">#</span>
<span class="c1">################################################################################</span>

<div class="viewcode-block" id="get_fisher_diagonal"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.get_fisher_diagonal">[docs]</a><span class="k">def</span> <span class="nf">get_fisher_diagonal</span><span class="p">(</span><span class="n">samples_fisher</span><span class="p">,</span> <span class="n">par_names</span><span class="p">,</span> <span class="n">x0_swap</span><span class="p">,</span> <span class="n">flm</span><span class="p">,</span> <span class="n">FLI_swap</span><span class="p">,</span><span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">start_safe</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get the diagonal elements of the fisher matrix for all parameters&quot;&quot;&quot;</span>
    <span class="c1">#this print out occurs a bit excessively frequently</span>
    <span class="c1">#print(&quot;Updating Fisher Diagonals&quot;)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">par_names</span><span class="p">)</span>
    <span class="n">fisher_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="c1">#TODO pass directly and fix elsewhere</span>
    <span class="n">Npsr</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">Npsr</span><span class="c1">#x0_swap.idx_rn_gammas.size</span>

    <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">samples_fisher</span><span class="p">)</span>
    <span class="c1">#we will update FLI_swap later to prevent having to do it twice</span>

    <span class="c1">#future locations</span>
    <span class="n">mms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">pps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">nns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">epsilons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

    <span class="n">sigma_defaults</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
    <span class="n">sigma_defaults</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">sigma_noise_default</span>
    <span class="n">sigma_defaults</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">sigma_noise_default</span>
    <span class="n">sigma_defaults</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_dists</span><span class="p">]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">sigma_cw0_p_dist_default</span>
    <span class="n">sigma_defaults</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_phases</span><span class="p">]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">sigma_cw0_p_phase_default</span>
    <span class="n">sigma_defaults</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_log10_fgw</span><span class="p">]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">sigma_log10_fgw_default</span>
    <span class="n">sigma_defaults</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_log10_h</span><span class="p">]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">sigma_log10_h_default</span>
    <span class="n">sigma_defaults</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb</span><span class="p">]</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">sigma_gwb_default</span>

    <span class="n">epsilon_gammas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="s1">&#39;red_noise_gamma&#39;</span><span class="p">]</span>
    <span class="n">epsilon_log10_As</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="s1">&#39;red_noise_log10_A&#39;</span><span class="p">]</span>

    <span class="c1">#adapt epsilon to be a bit bigger at low amplitude values</span>
    <span class="n">epsilon_gammas</span><span class="p">[</span><span class="n">samples_fisher</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cm</span><span class="o">.</span><span class="n">eps_log10_A_small_cut</span><span class="p">]</span> <span class="o">*=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps_rn_diag_gamma_small_mult</span>
    <span class="n">epsilon_log10_As</span><span class="p">[</span><span class="n">samples_fisher</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cm</span><span class="o">.</span><span class="n">eps_log10_A_small_cut</span><span class="p">]</span> <span class="o">*=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps_rn_diag_log10_A_small_mult</span>
    <span class="n">epsilon_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Npsr</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="s1">&#39;cw0_p_dist&#39;</span><span class="p">]</span>
    <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon_gammas</span>
    <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon_log10_As</span>
    <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_dists</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon_dists</span>
    <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb_gamma</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="s1">&#39;gwb_gamma&#39;</span><span class="p">]</span>
    <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb_log10_A</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="s1">&#39;gwb_log10_A&#39;</span><span class="p">]</span>

    <span class="n">pp2s</span><span class="p">,</span><span class="n">mm2s</span><span class="p">,</span><span class="n">nn2s</span><span class="p">,</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">pps_gwb</span><span class="p">,</span><span class="n">mms_gwb</span><span class="p">,</span><span class="n">nns_gwb</span> <span class="o">=</span> <span class="n">fisher_rn_mm_pp_diagonal_helper</span><span class="p">(</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span>\
                                                                   <span class="n">par_names</span><span class="p">,</span><span class="n">epsilon_gammas</span><span class="p">,</span><span class="n">epsilon_log10_As</span><span class="p">,</span><span class="n">Npsr</span><span class="p">,</span>\
                                                                   <span class="n">get_intrinsic_diag</span><span class="o">=</span><span class="n">get_intrinsic_diag</span><span class="p">,</span><span class="n">start_safe</span><span class="o">=</span><span class="n">start_safe</span><span class="p">,</span>\
                                                                   <span class="n">get_gwb</span><span class="o">=</span><span class="p">(</span><span class="n">get_intrinsic_diag</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cm</span><span class="o">.</span><span class="n">use_default_gwb_sigma</span><span class="p">))</span>
    <span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span> <span class="o">=</span> <span class="n">helper_tuple0</span>

    <span class="k">if</span> <span class="n">get_intrinsic_diag</span><span class="p">:</span>
        <span class="n">pps</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp2s</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mms</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">]</span> <span class="o">=</span> <span class="n">mm2s</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nns</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn2s</span>

        <span class="n">pps</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp2s</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mms</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span> <span class="o">=</span> <span class="n">mm2s</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nns</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">]</span> <span class="o">=</span> <span class="n">nn2s</span>

        <span class="n">pps</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb</span><span class="p">]</span> <span class="o">=</span> <span class="n">pps_gwb</span><span class="p">[:]</span>
        <span class="n">mms</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb</span><span class="p">]</span> <span class="o">=</span> <span class="n">mms_gwb</span><span class="p">[:]</span>
        <span class="n">nns</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb</span><span class="p">]</span> <span class="o">=</span> <span class="n">nns_gwb</span><span class="p">[:]</span>

        <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

        <span class="n">helper_tuple_dists_PP</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_dists</span><span class="p">,</span><span class="n">epsilon_dists</span><span class="p">,</span><span class="n">dist_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">helper_tuple_dists_MM</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_dists</span><span class="p">,</span><span class="o">-</span><span class="n">epsilon_dists</span><span class="p">,</span><span class="n">dist_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">pps</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_dists</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_dists_PP</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">dist_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mms</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_dists</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_dists_MM</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">dist_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nns</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_dists</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">dist_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

    <span class="n">epsilon_phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Npsr</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="s1">&#39;cw0_p_phase&#39;</span><span class="p">]</span>
    <span class="n">helper_tuple_phases_PP</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_phases</span><span class="p">,</span><span class="n">epsilon_phases</span><span class="p">,</span><span class="n">phase_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">helper_tuple_phases_MM</span> <span class="o">=</span> <span class="n">params_perturb_helper</span><span class="p">(</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">flm</span><span class="p">,</span><span class="n">par_names</span><span class="p">,</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_phases</span><span class="p">,</span><span class="o">-</span><span class="n">epsilon_phases</span><span class="p">,</span><span class="n">phase_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">pps</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_phases</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_phases_PP</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">phase_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mms</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_phases</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple_phases_MM</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">phase_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nns</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_phases</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_synthetic_FLI_helper</span><span class="p">(</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">phase_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">epsilons</span><span class="p">[</span><span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_phases</span><span class="p">]</span> <span class="o">=</span> <span class="n">epsilon_phases</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">fisher_diag</span><span class="o">&gt;=</span><span class="mf">0.</span><span class="p">)</span>

    <span class="n">chol_Sigmas_save</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Npsr</span><span class="p">):</span>
        <span class="n">chol_Sigmas_save</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">chol_Sigmas</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="c1">#calculate diagonal elements</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="n">paramsPP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">samples_fisher</span><span class="p">)</span>
        <span class="n">paramsMM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">samples_fisher</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_phases</span><span class="p">:</span><span class="c1">#&#39;_cw0_p_phase&#39; in par_names[i]:</span>
            <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">use_default_cw0_p_sigma</span><span class="p">:</span>
                <span class="n">fisher_diag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">cm</span><span class="o">.</span><span class="n">sigma_cw0_p_phase_default</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1">#otherwise should already have been done</span>

        <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_cw_ext</span><span class="p">:</span><span class="c1">#par_names_cw_ext:</span>
            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="n">par_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">epsilons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>

            <span class="n">paramsPP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>
            <span class="n">paramsMM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>

            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>

            <span class="n">nns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span><span class="c1">#,FLI_swap.resres,FLI_swap.logdet,FLI_swap.pos,FLI_swap.pdist,FLI_swap.NN,FLI_swap.MMs)</span>

            <span class="c1">#use fast likelihood</span>
            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsPP</span><span class="p">)</span>

            <span class="n">pps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span><span class="c1">#FLI_swap.resres,FLI_swap.logdet,FLI_swap.pos,FLI_swap.pdist,FLI_swap.NN,FLI_swap.MMs)</span>

            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsMM</span><span class="p">)</span>

            <span class="n">mms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span><span class="c1">#FLI_swap.resres,FLI_swap.logdet,FLI_swap.pos,FLI_swap.pdist,FLI_swap.NN,FLI_swap.MMs)</span>

            <span class="c1">#revert changes</span>
            <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_dists</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">use_default_cw0_p_sigma</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">get_intrinsic_diag</span><span class="p">:</span>
                <span class="n">fisher_diag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">cm</span><span class="o">.</span><span class="n">sigma_cw0_p_dist_default</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1">#should already have been done otherwise</span>

        <span class="k">elif</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_gammas</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_rn_log10_As</span><span class="p">):</span>
            <span class="c1">#continue</span>
            <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">use_default_noise_sigma</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">get_intrinsic_diag</span><span class="p">:</span>
                <span class="n">fisher_diag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">cm</span><span class="o">.</span><span class="n">sigma_noise_default</span><span class="o">**</span><span class="mi">2</span>
            <span class="c1">#already did all of the above otherwise</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_gwb</span><span class="p">:</span>
            <span class="c1">#default gwb indices if requested, otherwise we should already have them</span>
            <span class="k">if</span> <span class="n">cm</span><span class="o">.</span><span class="n">use_default_gwb_sigma</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">get_intrinsic_diag</span><span class="p">:</span>
                <span class="n">fisher_diag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">cm</span><span class="o">.</span><span class="n">sigma_gwb_default</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">get_intrinsic_diag</span><span class="p">:</span>
                <span class="c1">#don&#39;t need this value</span>
                <span class="n">fisher_diag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">cm</span><span class="o">.</span><span class="n">sigma_noise_default</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">continue</span>

            <span class="n">epsilon</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">eps</span><span class="p">[</span><span class="n">par_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">epsilons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>

            <span class="n">paramsPP</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>
            <span class="n">paramsMM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>

            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>

            <span class="n">nns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>


            <span class="c1">#must be one of the intrinsic parameters</span>
            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsPP</span><span class="p">)</span>

            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">update_intrinsic_params</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span> <span class="c1">#these are reset to nonzero by calling update_intrinsic, but they do not vary so don&#39;t include them in the likelihood</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">pps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span><span class="c1">#FLI_swap.resres,FLI_swap.logdet,FLI_swap.pos,FLI_swap.pdist,FLI_swap.NN,FLI_swap.MMs)</span>

            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsMM</span><span class="p">)</span>

            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">update_intrinsic_params</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">mms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span><span class="c1">#,FLI_swap.resres,FLI_swap.logdet,FLI_swap.pos,FLI_swap.pdist,FLI_swap.NN,FLI_swap.MMs)</span>

            <span class="c1">#calculate diagonal elements of the Hessian from a central finite element scheme</span>
            <span class="c1">#note the minus sign compared to the regular Hessian</span>
            <span class="c1">#fisher_diag[i] = -(pps[i] - 2*nns[i] + mms[i])/(4*epsilon*epsilon)</span>

            <span class="c1">#revert changes</span>
            <span class="c1">#x0_swap.update_params(samples_fisher)</span>

            <span class="c1">#FLI_swap.cos_gwtheta = x0_swap.cos_gwtheta</span>
            <span class="c1">#FLI_swap.gwphi = x0_swap.gwphi</span>
            <span class="c1">#FLI_swap.log10_fgw = x0_swap.log10_fgw</span>
            <span class="c1">#FLI_swap.log10_mc = x0_swap.log10_mc#</span>

            <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="c1">#calculate diagonal elements of the Hessian from a central finite element scheme</span>
        <span class="c1">#note the minus sign compared to the regular Hessian</span>
        <span class="c1">#defaulted values will already be nonzero so don&#39;t overwrite them</span>
        <span class="k">if</span> <span class="n">fisher_diag</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">fisher_diag</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">pps</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">nns</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">mms</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">epsilons</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="c1">#+1./sigma_defaults[ii]**2</span>
            <span class="k">if</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_int</span><span class="p">:</span>
                <span class="n">fisher_diag</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sigma_defaults</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fisher_diag</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="ow">or</span> <span class="n">fisher_diag</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.</span> <span class="p">:</span>
            <span class="n">fisher_diag</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">sigma_defaults</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="c1">#1./cm.sigma_noise_default**2#1/cm.sigma_cw0_p_phase_default**2</span>

    <span class="c1">#double check FLI_swap and x0_swap are a self consistent state</span>
    <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">samples_fisher</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>

    <span class="c1">#filer out nans and negative values - set them to 1.0 which will result in</span>
    <span class="n">fisher_diag</span><span class="p">[(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fisher_diag</span><span class="p">))</span><span class="o">|</span><span class="p">(</span><span class="n">fisher_diag</span><span class="o">&lt;</span><span class="mf">0.</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="c1">#filter values smaller than 4 and set those to 4 -- Neil&#39;s trick -- effectively not allow jump Gaussian stds larger than 0.5=1/sqrt(4)</span>
    <span class="n">eig_limit</span> <span class="o">=</span> <span class="mf">4.0</span>
    <span class="c1">#W = np.where(FISHER_diag&gt;eig_limit, FISHER_diag, eig_limit)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fisher_diag</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">&lt;</span><span class="n">eig_limit</span><span class="p">:</span>
            <span class="c1">#use input defaults instead of the eig limit</span>
            <span class="k">if</span> <span class="n">sigma_defaults</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.</span><span class="p">:</span>
                <span class="n">fisher_diag</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sigma_defaults</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fisher_diag</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">eig_limit</span>
    <span class="c1">#for phases override the eig limit</span>

    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fisher_diag</span><span class="p">),(</span><span class="n">pp2s</span><span class="p">,</span><span class="n">mm2s</span><span class="p">,</span><span class="n">nn2s</span><span class="p">,</span><span class="n">epsilons</span><span class="p">,</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">pps</span><span class="p">,</span><span class="n">mms</span><span class="p">,</span><span class="n">nns</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_fisher_eigenvectors_common"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.get_fisher_eigenvectors_common">[docs]</a><span class="k">def</span> <span class="nf">get_fisher_eigenvectors_common</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">x0_swap</span><span class="p">,</span> <span class="n">FLI_swap</span><span class="p">,</span> <span class="n">diagonal_data</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">default_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;update just the 4x4 block of common eigenvectors&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updating Common Parameter Fisher Eigenvectors&quot;</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">idx_to_perturb</span> <span class="o">=</span> <span class="n">x0_swap</span><span class="o">.</span><span class="n">idx_cw_int</span><span class="p">[:</span><span class="n">dim</span><span class="p">]</span>
    <span class="c1">#par_names_to_perturb = par_names_cw_int[:4]</span>
    <span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">epsilons_diag</span><span class="p">,</span><span class="n">helper_tuple0</span><span class="p">,</span><span class="n">pps</span><span class="p">,</span><span class="n">mms</span><span class="p">,</span><span class="n">nns</span> <span class="o">=</span> <span class="n">diagonal_data</span>
    <span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span> <span class="o">=</span> <span class="n">helper_tuple0</span>

    <span class="n">fisher</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
    <span class="n">sigma_defaults</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cm</span><span class="o">.</span><span class="n">sigma_noise_default</span><span class="p">,</span><span class="n">cm</span><span class="o">.</span><span class="n">sigma_noise_default</span><span class="p">,</span><span class="n">cm</span><span class="o">.</span><span class="n">sigma_log10_fgw_default</span><span class="p">,</span><span class="n">cm</span><span class="o">.</span><span class="n">sigma_noise_default</span><span class="p">])</span>
    <span class="n">diag_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">default_all</span><span class="p">:</span>
        <span class="c1">#option just make all the fishers their default values for initialization</span>
        <span class="k">for</span> <span class="n">itrp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sigma_defaults</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">diag_bad</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#calculate diagonal elements</span>
        <span class="k">for</span> <span class="n">itrp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">idx_par</span> <span class="o">=</span> <span class="n">idx_to_perturb</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span>
            <span class="c1">#check not a factor of 4 in the denominator? Maybe is absorbed because epsilon is 2x as large when diagonal elements are computed</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">pps</span><span class="p">[</span><span class="n">idx_par</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">nns</span><span class="p">[</span><span class="n">idx_par</span><span class="p">]</span> <span class="o">+</span> <span class="n">mms</span><span class="p">[</span><span class="n">idx_par</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">epsilons_diag</span><span class="p">[</span><span class="n">idx_par</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="c1">#+1./sigma_defaults[itrp]**2</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">])</span> <span class="ow">or</span> <span class="n">fisher</span><span class="p">[</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span><span class="o">&lt;=</span><span class="mf">0.</span><span class="p">:</span>  <span class="c1"># diagonal elements cannot be 0 or negative</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;bad diagonal&#39;</span><span class="p">,</span><span class="n">itrp</span><span class="p">,</span><span class="n">idx_par</span><span class="p">,</span><span class="n">pps</span><span class="p">[</span><span class="n">idx_par</span><span class="p">],</span><span class="n">nns</span><span class="p">[</span><span class="n">idx_par</span><span class="p">],</span><span class="n">mms</span><span class="p">[</span><span class="n">idx_par</span><span class="p">],</span><span class="n">epsilons_diag</span><span class="p">[</span><span class="n">idx_par</span><span class="p">],</span><span class="n">fisher</span><span class="p">[</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">],</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sigma_defaults</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">fisher</span><span class="p">[</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sigma_defaults</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># TODO pick defaults for diagonals more intelligently</span>
                <span class="n">diag_bad</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">fisher</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diag_bad</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1">#several went bad, so just assume they all did and default everything to diagonal defaults</span>
            <span class="k">for</span> <span class="n">itrp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">fisher</span><span class="p">[</span><span class="n">itrp</span><span class="p">,</span><span class="n">itrp</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">sigma_defaults</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> 
                <span class="n">diag_bad</span><span class="p">[</span><span class="n">itrp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1">#calculate off-diagonal elements</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
        <span class="c1">#don&#39;t bother calculating the off-diagonals if we didn&#39;t get a good diagonal component for either</span>
        <span class="k">if</span> <span class="n">diag_bad</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="p">):</span>
            <span class="c1">#don&#39;t bother calculating the off-diagonals if we didn&#39;t get a good diagonal component for either</span>
            <span class="k">if</span> <span class="n">diag_bad</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1">#create parameter vectors with ++, --, +-, -+ epsilon in the ith and jth component</span>
            <span class="n">paramsPP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">paramsMM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">paramsPM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">paramsMP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

            <span class="n">paramsPP</span><span class="p">[</span><span class="n">idx_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">epsilon</span>
            <span class="n">paramsPP</span><span class="p">[</span><span class="n">idx_to_perturb</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">epsilon</span>
            <span class="n">paramsMM</span><span class="p">[</span><span class="n">idx_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">epsilon</span>
            <span class="n">paramsMM</span><span class="p">[</span><span class="n">idx_to_perturb</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">epsilon</span>
            <span class="n">paramsPM</span><span class="p">[</span><span class="n">idx_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">epsilon</span>
            <span class="n">paramsPM</span><span class="p">[</span><span class="n">idx_to_perturb</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">epsilon</span>
            <span class="n">paramsMP</span><span class="p">[</span><span class="n">idx_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">epsilon</span>
            <span class="n">paramsMP</span><span class="p">[</span><span class="n">idx_to_perturb</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">epsilon</span>

            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>

            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsPP</span><span class="p">)</span>

            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">update_intrinsic_params</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="c1">#these are reset to nonzero by calling update_intrinsic, but they do not vary so don&#39;t include them in the likelihood</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>

            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsMM</span><span class="p">)</span>

            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">update_intrinsic_params</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">mm</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>

            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsPM</span><span class="p">)</span>

            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">update_intrinsic_params</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">pm</span> <span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>

            <span class="n">x0_swap</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">paramsMP</span><span class="p">)</span>

            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">update_intrinsic_params</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">FLI_swap</span><span class="o">.</span><span class="n">set_resres_logdet</span><span class="p">(</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">resres_array</span><span class="p">,</span><span class="n">FLI_swap</span><span class="o">.</span><span class="n">logdet_array</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">mp</span><span class="o">=</span> <span class="n">FLI_swap</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">x0_swap</span><span class="p">)</span>

            <span class="n">safe_reset_swap</span><span class="p">(</span><span class="n">FLI_swap</span><span class="p">,</span><span class="n">x0_swap</span><span class="p">,</span><span class="n">params</span><span class="p">,</span><span class="n">FLI_mem0</span><span class="p">)</span>


            <span class="c1">#calculate off-diagonal elements of the Hessian from a central finite element scheme</span>
            <span class="c1">#note the minus sign compared to the regular Hessian</span>
            <span class="n">fisher_loc</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">pp</span> <span class="o">-</span> <span class="n">mp</span> <span class="o">-</span> <span class="n">pm</span> <span class="o">+</span> <span class="n">mm</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">epsilon</span><span class="o">*</span><span class="n">epsilon</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fisher_loc</span><span class="p">):</span>
                <span class="n">fisher_loc</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="n">fisher</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_loc</span>  <span class="c1"># -(pp - mp - pm + mm)/(4.0*epsilon*epsilon)</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher_loc</span>  <span class="c1"># fisher[i,j]</span>
            <span class="c1">#fisher[j,i] = -(pp - mp - pm + mm)/(4.0*epsilon*epsilon)</span>

    <span class="c1">#if determinant is too small, rescale all off diagonal elements</span>
    <span class="c1">#by a common factor to increase the determinant while preserving as much structure as possible</span>
    <span class="n">diag_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">fisher</span><span class="p">))</span>
    <span class="n">det_min_abs</span> <span class="o">=</span> <span class="mf">4.</span><span class="o">**</span><span class="n">dim</span>  <span class="c1"># minimum value to allow the determinant of the matrix to be</span>
    <span class="n">det_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">det_min_abs</span><span class="p">,</span><span class="mf">1.e-1</span><span class="o">*</span><span class="n">diag_prod</span><span class="p">)</span>  <span class="c1"># either use absolute minimum or enforce that matrix must be relatively diagonally dominat</span>
    <span class="n">fisher_det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">fisher</span><span class="p">)</span>
    <span class="c1">#print(fisher_det)</span>
    <span class="n">itrt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#off diagonal term may sometimes need to be shrunk multiple times due to numerical precision limits in the multiplier</span>
    <span class="k">while</span> <span class="n">fisher_det</span> <span class="o">&lt;</span> <span class="n">det_min</span> <span class="ow">and</span> <span class="n">itrt</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">:</span>
        <span class="n">offdiag_prod</span> <span class="o">=</span> <span class="n">diag_prod</span><span class="o">-</span><span class="n">fisher_det</span>
        <span class="k">if</span> <span class="n">diag_prod</span><span class="o">&lt;=</span><span class="n">det_min</span><span class="p">:</span>
            <span class="c1">#cannot fix by rescaling so turn off off-diagonals and rescale diagonals</span>
            <span class="n">offdiag_mult</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">fisher_scale</span> <span class="o">=</span> <span class="mf">1.1</span>
            <span class="n">det_enhance</span> <span class="o">=</span> <span class="mf">1.1</span>
            <span class="k">for</span> <span class="n">itr1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">fisher</span><span class="p">[</span><span class="n">itr1</span><span class="p">,</span><span class="n">itr1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fisher_scale</span><span class="o">*</span><span class="p">(</span><span class="n">det_min</span><span class="o">*</span><span class="n">det_enhance</span><span class="o">/</span><span class="n">diag_prod</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fisher_scale</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="n">det_enhance</span> <span class="o">=</span> <span class="mf">2.</span>
            <span class="k">if</span> <span class="n">offdiag_prod</span><span class="o">&gt;</span><span class="mf">0.</span><span class="p">:</span>
                <span class="n">offdiag_mult</span> <span class="o">=</span> <span class="n">fisher_scale</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diag_prod</span><span class="o">-</span><span class="n">det_min</span><span class="o">*</span><span class="n">det_enhance</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">offdiag_prod</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offdiag_mult</span> <span class="o">=</span> <span class="n">fisher_scale</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">det_min</span><span class="o">*</span><span class="n">det_enhance</span><span class="o">-</span><span class="n">diag_prod</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">offdiag_prod</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">itr1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">itr2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">itr1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">fisher</span><span class="p">[</span><span class="n">itr1</span><span class="p">,</span><span class="n">itr2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">offdiag_mult</span>
                <span class="n">fisher</span><span class="p">[</span><span class="n">itr2</span><span class="p">,</span><span class="n">itr1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher</span><span class="p">[</span><span class="n">itr1</span><span class="p">,</span><span class="n">itr2</span><span class="p">]</span>

        <span class="n">fisher_det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">fisher</span><span class="p">)</span>
        <span class="n">itrt</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1">#    print(np.linalg.det(fisher),diag_prod,offdiag_prod,det_min,offdiag_mult)</span>
    <span class="c1">#    print(np.linalg.det(fisher)-det_min,diag_prod-offdiag_prod*offdiag_mult**dim)</span>
    <span class="c1">#assert np.linalg.det(fisher)&gt;=det_min</span>

    <span class="c1">#Filter nans and infs and replace them with 1s</span>
    <span class="c1">#this will imply that we will set the eigenvalue to 100 a few lines below</span>
    <span class="c1">#print(&#39;fisher 1&#39;)</span>
    <span class="c1">#print(fisher)</span>
    <span class="c1">#print(&#39;fisher det raw &#39;,np.linalg.det(fisher),np.prod(np.diagonal(fisher)))</span>

    <span class="n">FISHER</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fisher</span><span class="p">),</span> <span class="n">fisher</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">FISHER</span><span class="p">,</span> <span class="n">fisher</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Changed some nan elements in the Fisher matrix to 1.0&quot;</span><span class="p">)</span>

    <span class="c1">#Find eigenvalues and eigenvectors of the Fisher matrix</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">FISHER</span><span class="p">)</span>

    <span class="c1">#filter w for eigenvalues smaller than 100 and set those to 100 -- Neil&#39;s trick</span>
    <span class="n">eig_limit</span> <span class="o">=</span> <span class="mf">1.0</span><span class="c1">#1.0#0.25</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;eig sizes&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>

    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">&gt;</span><span class="n">eig_limit</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">eig_limit</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">W</span><span class="p">))</span><span class="o">*</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="get_fisher_eigenvectors"><a class="viewcode-back" href="../../QuickCW.html#QuickCW.QuickFisherHelpers.get_fisher_eigenvectors">[docs]</a><span class="k">def</span> <span class="nf">get_fisher_eigenvectors</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">par_names</span><span class="p">,</span> <span class="n">par_names_to_perturb</span><span class="p">,</span> <span class="n">pta</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;get fisher eigenvectors for a generic set of parameters the slow way&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">)</span>
        <span class="n">fisher</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>

        <span class="c1">#lnlikelihood at specified point</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="n">pta</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="c1">#calculate diagonal elements</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="c1">#create parameter vectors with +-epsilon in the ith component</span>
            <span class="n">paramsPP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">paramsMM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">paramsPP</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>
            <span class="n">paramsMM</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span>

            <span class="c1">#lnlikelihood at +-epsilon positions</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">pta</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">paramsPP</span><span class="p">)</span>
            <span class="n">mm</span> <span class="o">=</span> <span class="n">pta</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">paramsMM</span><span class="p">)</span>

            <span class="c1">#calculate diagonal elements of the Hessian from a central finite element scheme</span>
            <span class="c1">#note the minus sign compared to the regular Hessian</span>
            <span class="n">fisher</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">pp</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">nn</span> <span class="o">+</span> <span class="n">mm</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">epsilon</span><span class="o">*</span><span class="n">epsilon</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">fisher</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.</span><span class="p">:</span>  <span class="c1"># diagonal elements must be postive</span>
                <span class="n">fisher</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.</span>

        <span class="c1">#calculate off-diagonal elements</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="p">):</span>
                <span class="c1">#create parameter vectors with ++, --, +-, -+ epsilon in the ith and jth component</span>
                <span class="n">paramsPP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="n">paramsMM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="n">paramsPM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="n">paramsMP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

                <span class="n">paramsPP</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">+=</span> <span class="n">epsilon</span>
                <span class="n">paramsPP</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">j</span><span class="p">])]</span> <span class="o">+=</span> <span class="n">epsilon</span>
                <span class="n">paramsMM</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">-=</span> <span class="n">epsilon</span>
                <span class="n">paramsMM</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">j</span><span class="p">])]</span> <span class="o">-=</span> <span class="n">epsilon</span>
                <span class="n">paramsPM</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">+=</span> <span class="n">epsilon</span>
                <span class="n">paramsPM</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">j</span><span class="p">])]</span> <span class="o">-=</span> <span class="n">epsilon</span>
                <span class="n">paramsMP</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">-=</span> <span class="n">epsilon</span>
                <span class="n">paramsMP</span><span class="p">[</span><span class="n">par_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">[</span><span class="n">j</span><span class="p">])]</span> <span class="o">+=</span> <span class="n">epsilon</span>

                <span class="n">pp</span> <span class="o">=</span> <span class="n">pta</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">paramsPP</span><span class="p">)</span>
                <span class="n">mm</span> <span class="o">=</span> <span class="n">pta</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">paramsMM</span><span class="p">)</span>
                <span class="n">pm</span> <span class="o">=</span> <span class="n">pta</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">paramsPM</span><span class="p">)</span>
                <span class="n">mp</span> <span class="o">=</span> <span class="n">pta</span><span class="o">.</span><span class="n">get_lnlikelihood</span><span class="p">(</span><span class="n">paramsMP</span><span class="p">)</span>

                <span class="c1">#calculate off-diagonal elements of the Hessian from a central finite element scheme</span>
                <span class="c1">#note the minus sign compared to the regular Hessian</span>
                <span class="n">fisher</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">pp</span> <span class="o">-</span> <span class="n">mp</span> <span class="o">-</span> <span class="n">pm</span> <span class="o">+</span> <span class="n">mm</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">epsilon</span><span class="o">*</span><span class="n">epsilon</span><span class="p">)</span>
                <span class="n">fisher</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fisher</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="c1">#fisher[j,i] = -(pp - mp - pm + mm)/(4.0*epsilon*epsilon)</span>

        <span class="c1">#Filter nans and infs and replace them with 1s</span>
        <span class="c1">#this will imply that we will set the eigenvalue to 100 a few lines below</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fisher 2&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">fisher</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fisher determinant&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">fisher</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">fisher</span><span class="p">)))</span>
        <span class="n">FISHER</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fisher</span><span class="p">),</span> <span class="n">fisher</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">FISHER</span><span class="p">,</span> <span class="n">fisher</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Changed some nan elements in the Fisher matrix to 1.0&quot;</span><span class="p">)</span>

        <span class="c1">#Find eigenvalues and eigenvectors of the Fisher matrix</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">FISHER</span><span class="p">)</span>

        <span class="c1">#filter w for eigenvalues smaller than 100 and set those to 100 -- Neil&#39;s trick</span>
        <span class="n">eig_limit</span> <span class="o">=</span> <span class="mf">4.0</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">&gt;</span><span class="n">eig_limit</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">eig_limit</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">W</span><span class="p">))</span><span class="o">*</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;An Error occured in the eigenvalue calculation&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">par_names_to_perturb</span><span class="p">))</span><span class="o">*</span><span class="mf">0.5</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Bence Becsy, Neil Cornish, Matthew Digman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>